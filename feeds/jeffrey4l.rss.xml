<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Xcodest - Jeffrey4l</title><link>http://xcodest.me/</link><description>code for fun</description><lastBuildDate>Thu, 23 Feb 2017 00:00:00 +0800</lastBuildDate><item><title>Nova Cell V2 详解</title><link>http://xcodest.me/nova-cell-v2.html</link><description>&lt;p&gt; 现在 ，OpenStack  在控制平面上的性能瓶颈主要在  Message Queue  和  Database 。 尤其是  Message Queue ,  随着计算节点的增加 ， 性能变的越来越差 。 为了应对这种情况 ， Nova  很早之前提出来  nova-cell ( 以下以  cellv1  代替 )   的解决方案 。 目的是在把大的  OpenStack  集群分成小的单元 ， 每个单元有自己的  Message Queue  和  Database。 以此来解决规模增加时引起的性能问题 。 而且不会向  Region  那样 ， 把各个集群独立运行 。 在  cell  里面 ，Keystone、Neutron、Cinder、Glance  等资源还是共享的 。&lt;/p&gt;
&lt;div class="section" id="cell-v1"&gt;
&lt;h2&gt;cell v1&lt;/h2&gt;
&lt;p&gt;cellv1  最初的想法很好 ， 但是局限于早期  nova  的架构 ， 硬生生的加个  nova-cell …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 23 Feb 2017 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2017-02-23:/nova-cell-v2.html</guid><category>OpenStack</category><category>Kolla</category></item><item><title>Ansible with-items auto flatten list of lists</title><link>http://xcodest.me/ansible-with-items-auto-flatten-list-of-lists.html</link><description>&lt;p&gt;Ansible has &lt;tt class="docutils literal"&gt;with_items&lt;/tt&gt; directive, which make task iterating the lists in
&lt;tt class="docutils literal"&gt;with_items&lt;/tt&gt;. A normal usage is like&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- name: copy file
  copy: src={{ item }} dest=/root/.ssh/{{ item }}
  with_items:
    - id_rsa
    - id_rsa.pub
&lt;/pre&gt;
&lt;p&gt;But if you use list of lists, it will not work as your expect.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- name: copy file
  copy: src …&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 27 Dec 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-12-27:/ansible-with-items-auto-flatten-list-of-lists.html</guid><category>Ansible</category></item><item><title>CentOS 根分区自动扩展</title><link>http://xcodest.me/centos-root-partition-auto-grow.html</link><description>&lt;p&gt;CentOS 5  太老了 ， 完全不支持 。&lt;/p&gt;
&lt;p&gt;CentOS 6  要实现分区自动扩展 ， 要安装以下三个包 &lt;/p&gt;
&lt;pre class="literal-block"&gt;
yum install cloud-init cloud-utils-growpart dracut-modules-growroot
#  生新生成  initramfs
dracut -f
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;dracut&lt;/tt&gt;  把  &lt;tt class="docutils literal"&gt;growroot&lt;/tt&gt;  的脚本封装到  &lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  里面 。  把系统启动时 ，
&lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  利用  &lt;tt class="docutils literal"&gt;growpart&lt;/tt&gt;  命令把根分区进行扩展 。 然后启动真正的 
&lt;tt class="docutils literal"&gt;kernel&lt;/tt&gt;,  之后  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cloud-init&lt;/span&gt;&lt;/tt&gt;  服务会自动把文件系统进行扩展 。&lt;/p&gt;
&lt;p&gt; 之所以使用  &lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  这种方式 ， 原因 [0]：&lt;/p&gt;
&lt;blockquote&gt;
Growpart called by cloud-init only works for kernels &amp;gt;3.8. Only newer …&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 14 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-11-14:/centos-root-partition-auto-grow.html</guid><category>Linux</category><category>OpenStack</category></item><item><title>Docker init 进程</title><link>http://xcodest.me/docker-init-process.html</link><description>&lt;p&gt; 应用容器化后 ， 重启容器的时候 ， 经常会很慢 ， 而且 docker daemon  日志中经常会抛出以 
 下错误 &lt;/p&gt;
&lt;pre class="literal-block"&gt;
dockerd[559]: msg=&amp;quot;Container 5054f failed to exit within 10 seconds of
signal 15 - using the force&amp;quot;
&lt;/pre&gt;
&lt;p&gt; 默认的的  signal 15  根本就没有使其退出 ， 最后还是  10  秒超时后强制退出 (kill) 的 。 而 
 且有时还会出现大量僵尸进程 &lt;/p&gt;
&lt;p&gt; 这可不是一个好现象 。 本文解释其原因及解决方法 。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 背景知识 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt; 信号 &lt;/h3&gt;
&lt;p&gt; 这个是  Linux  最常见一个概念 ， 一般杀死进程时都会用到  &lt;tt class="docutils literal"&gt;kill &amp;lt;pid&amp;gt;&lt;/tt&gt; 。  不同的信 
 号有不同的默认行为 。 用户可以注册自己的信号处理函数 ， 来覆盖掉默认行为 …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 07 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-11-07:/docker-init-process.html</guid><category>Linux</category><category>Docker</category></item><item><title>Reset Password in Systemd</title><link>http://xcodest.me/reset-password-in-systemd.html</link><description>&lt;p&gt; 现在基本是用  ssh key  来登录系统了 。 之前可以直接在  GRUB  直接进单用户改密码 。 使用了  systemd  的系统 ， 后已经不可以这么使用了 。 原因是  Systemd  的单用户模式使用了  &lt;tt class="docutils literal"&gt;/usr/sbin/sulogin&lt;/tt&gt;  这个  shell,  也必须输入密码才可以 。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# /usr/lib/systemd/system/rescue.service
[Unit]
Description=Rescue Shell
Documentation=man:sulogin(8)
DefaultDependencies=no
Conflicts=shutdown.target
After=sysinit.target plymouth-start.service
Before=shutdown.target

[Service]
Environment=HOME …&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Sun, 28 Aug 2016 10:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-08-28:/reset-password-in-systemd.html</guid><category>Linux</category><category>Systemd</category></item><item><title>Code Review 神器 -- Gertty</title><link>http://xcodest.me/effective-code-review-tool-gertty.html</link><description>
&lt;p&gt; 现在很多项目都使用  Gerrit  做为代码  Review  工具 。OpenStack  所有的项目就是放在  Gerrit  上的 。Gerrit  提供了一个  Web  页面来做  Code Review。 今天我介绍一个更加高效的工具来处理  Gerrit Review。 它的名字叫  gertty。&lt;/p&gt;
&lt;p&gt;Gertty  的  OpenStack  下面的一个项目 &lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;， 官方的介绍是 ：Gertty is a console-based interface to the Gerrit Code Review system。 就是一个基于终端的  Gerrit  代码  Review  工具 。&lt;/p&gt;
&lt;p&gt; 相比较  Web  版本 ， 它的优势体现在 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 工作流程  - Gertty  的界面设计和邮件 、 网络消息的设计很类似 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 11 Apr 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-04-11:/effective-code-review-tool-gertty.html</guid><category>CodeReview</category></item><item><title>cloud-init 导致虚拟机启动太慢</title><link>http://xcodest.me/cloud-init-cause-vm-boot-slow.html</link><description>
&lt;h1 id="_1"&gt; 问题 &lt;/h1&gt;
&lt;p&gt; 在一个准生产环境中 ， 一直发现虚拟机启动太慢的问题 ， 现像是虚拟机很早就能  ping  到 ， 但是就是  ssh  不进去 。 要么报端口没有开启 ， 要么就  Public Key  不对 。 整个过程大概要 2 分多钟才能直接  ssh  进去 。&lt;/p&gt;
&lt;h1 id="_2"&gt; 背景知识 &lt;/h1&gt;
&lt;p&gt;cloud-init  这个服务是从  AWS  学来的 。 它安装在虚拟机中 ， 在启动虚拟机时 ， 做一些初始化工作 。 如 ： 硬盘分区自动扩展 ，SSH Public Key  注入 ， 用户创建等 。 用户甚至可以注入一些  shell  脚本到虚拟机中运行 。 在自动化方便启了很大的作用 。Heat  的实现就依赖于  cloud-init  服务 。&lt;/p&gt;
&lt;p&gt; 在  OpenStack  上 ，cloud-init  应该从  &lt;code&gt;http://169.254 …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Sun, 10 Apr 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-04-10:/cloud-init-cause-vm-boot-slow.html</guid><category>OpenStack</category></item><item><title>OpenStack Kolla AIO Install</title><link>http://xcodest.me/kolla-aio-install.html</link><description>
&lt;p&gt;Kolla  依赖于以下几个主要组件 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible &amp;gt; 1.9.4, &amp;lt; 2.0&lt;/li&gt;
&lt;li&gt;Docker &amp;gt; 1.10.0&lt;/li&gt;
&lt;li&gt;docker-py &amp;gt; 1.7.0&lt;/li&gt;
&lt;li&gt;python jinja2 &amp;gt; 2.6.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 几点说明 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 机器使用的是  kvm  虚拟机进行的测试 。 配置上使用  4G RAM, 2 CPU, 2  网卡的配置 &lt;/li&gt;
&lt;li&gt; 由于使用了  Docker， 所以对于底层系统并还没什么要求 ， 本文使用  CentOS 7  系统 。&lt;/li&gt;
&lt;li&gt;Kolla master  分支上使用的是  RDO master  上的源 ， 打包极不稳定 ， 时常会有  Bug  出现 。 所以本文使用的是 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 24 Feb 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-02-24:/kolla-aio-install.html</guid><category>Kolla</category><category>OpenStack</category></item><item><title>Kolla Mitaka Midcycle Discuss</title><link>http://xcodest.me/kolla-mitaka-midcycle-discuss.html</link><description>
&lt;p&gt;2016 年 2 月 9 日 -10 日 ，Kolla Team  举办了  Mitaka  的中期会议 ， 对遇到的问题 、 解决的方法及接下来的工作内容做了深入讨论 。&lt;/p&gt;
&lt;h1 id="_1"&gt; 讨论的优先级安排 &lt;/h1&gt;
&lt;p&gt; 首先对本次讨论进行了优先级安排 &lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upgrades：  这是现在的重中之重 。 如何能对现有的 Kolla 进行平滑的升级 。 包括  OpenStack  组件和基础服务组件 ( 如  MariaDB  等 )。&lt;/li&gt;
&lt;li&gt;diagnostics/logging:  主要是指  ELK。&lt;/li&gt;
&lt;li&gt;stability of deployment&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;backwards compatibility&lt;/li&gt;
&lt;li&gt;selinux&lt;/li&gt;
&lt;li&gt;kolla-ansible split&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="upgrade"&gt;Upgrade&lt;/h1&gt;
&lt;p&gt; 升级主要涉及到两部分 。 相关的 BP 在这里 &lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="#fn-3"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 是 OpenStack …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 16 Feb 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-02-16:/kolla-mitaka-midcycle-discuss.html</guid><category>Kolla</category></item><item><title>iptables forward the vrrp packets issue</title><link>http://xcodest.me/iptables-forward-the-vrrp-packets-issue.html</link><description>
&lt;p&gt;&lt;img alt=" 功夫熊猫 " class="img-responsive" src="images/kungfupanda.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 最近在整  Kolla  的多机部署 ， 没有物理环境还是在虚拟机上搞 。 不过今天被一个  keepalived  的问题卡了将近一天的时间 。 倒也不是啥大问题 ， 还是栽到了自己挖的坑里 。&lt;/p&gt;
&lt;h1 id="_1"&gt; 问题 &lt;/h1&gt;
&lt;p&gt; 先说一下自己的环境 ， 我使用了三台  kvm  虚拟机 ， 每台两张网卡 ， 一个用于上外网 (eth0 &lt;code&gt;10.2.0.0/24&lt;/code&gt;)， 一个用于  neutron  的  tenant  网络使用 (eth1)。 问题就出在  eth0  上面 。eth0  是桥在了我手动创建的一个桥上  (br0),  为了上外网 ， 我打开了  &lt;code&gt;ip_forward&lt;/code&gt;，  并加了一条  iptables  转发规则 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -t nat -A POSTROUTING -s 10.2.0.0 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 02 Feb 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-02-02:/iptables-forward-the-vrrp-packets-issue.html</guid><category>iptables</category><category>vrrp</category></item><item><title>OpenStack Kolla 项目介绍</title><link>http://xcodest.me/kolla-introduce.html</link><description>
&lt;h1 id="_1"&gt; 项目目标 &lt;/h1&gt;
&lt;p&gt;Kolla  提供了生产级别的  OpenStack Service Containers。 基于社区的最佳实践 ， 提供了 
 更好 ， 更快 ， 更可靠的 ,  操作  OpenStack  的部署工具 。&lt;/p&gt;
&lt;h1 id="_2"&gt; 解决的问题 &lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt; 平滑的升级 / 回滚  OpenStack&lt;/li&gt;
&lt;li&gt; 隔离  OpenStack  的不同组件的依赖环境 。 尤其是那些使用同一模块不同版本的情况 。&lt;/li&gt;
&lt;li&gt; 保证环境的一致性 。 解决由于安装时间不同 ， 造成的包版本不一致的情况 。&lt;/li&gt;
&lt;li&gt; 支持多种安装源 ： 源代码安装 ，CentOS binary  安装等 。 可以替代掉  devstack。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 其实这些问题只要是由  Docker  来解决的 。 这也是  Kolla  使用  Docker  的原因 。&lt;/p&gt;
&lt;h1 id="_3"&gt; 架构 &lt;/h1&gt;
&lt;p&gt;kolla  代码在 &lt;a href="https://github.com/openstack/kolla"&gt;https://github.com/openstack/kolla&lt;/a&gt;。 现在  Kolla …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-01-11:/kolla-introduce.html</guid><category>Kolla</category><category>OpenStack</category></item><item><title>Get all the repo from OpenStack</title><link>http://xcodest.me/get-all-repos-from-openstack.html</link><description>&lt;p&gt;OpenStack 的源因为你我都知道的原因 ， 一直不稳定 ， 导致  devstack  时经常失败 。 特定写了个脚本 ， 可以拿到所有的仓库地址 ， 方便做本地的 mirror。&lt;/p&gt;
&lt;p&gt; 脚本在  gist&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;  上 。&lt;/p&gt;
&lt;p&gt; 使用方法 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install PyGithub
python openstack_repo.py -u &amp;lt;github_username&amp;gt; -p &amp;lt;github_password&amp;gt; \
    -o repos.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 跑一次才发现 ，OpenStack  组下已经有了 600 多个项目 。 好多啊 。&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/b6c36b9f74b743eb4c82.js?file=openstack_repos.py'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
import github
import argparse
import codecs
import logging


DESCRIPTION=u''' …&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 06 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-01-06:/get-all-repos-from-openstack.html</guid><category>OpenStach Python</category></item><item><title>Ansible Tower Usage</title><link>http://xcodest.me/ansible-tower-usage.html</link><description>
&lt;p&gt; 安装好后的  Tower  如下图 ( 图 1)&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ansible Tower" class="img-responsive" src="images/ansible/tower_preview.png"/&gt;&lt;/p&gt;
&lt;div class="text-center"&gt;
&lt;p&gt;&lt;strong&gt; 图 1&lt;/strong&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 从上面看 ， 主要有  Projects, Inventories, Job Templates, Jobs  几个功能点 。
 还有一个主要的是后面的  Setup。 我们一个一个来介绍下都是做什么用的 。 并建立起一个简单的例子 &lt;/p&gt;
&lt;h1 id="projects"&gt;Projects&lt;/h1&gt;
&lt;p&gt;Projects  里的主要内容是一个  Playbook  的代码地址 ， 可选项为 Manual( 手动指定位置 )，Git, Mercutail, Subversion。&lt;/p&gt;
&lt;p&gt; 我在 Github 上建立了一个简单的  PlayBook。 我们来创建一个新的  Project。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;project_demo&lt;/span&gt;
&lt;span class="n"&gt;Organization&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Default&lt;/span&gt;
&lt;span class="n"&gt;SCM&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Git&lt;/span&gt;
&lt;span class="n"&gt;SCM&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;com&lt;/span&gt;&lt;span class="sr"&gt;/jeffrey4l/&lt;/span&gt;&lt;span class="n"&gt;tower_test …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Sat, 02 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2016-01-02:/ansible-tower-usage.html</guid><category>Ansible Tower</category></item><item><title>Install Ansible Tower</title><link>http://xcodest.me/install-ansible-tower.html</link><description>
&lt;h1 id="_1"&gt; 手动安装 &lt;/h1&gt;
&lt;h2 id="_2"&gt; 下载安装包 &lt;/h2&gt;
&lt;p&gt; 从  http://www.ansible.com/tower-trial  下载 ， 需要填个人信息 ， 提交后会自动下载 。&lt;/p&gt;
&lt;p&gt; 把安装包复制到要安装的机器中去 ， 解压准备安装 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar xvf ansible-tower-setup-latest.tar.gz
cd ansible-tower-setup-2.4.3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个安装包本质上是一个 playbook。 其中 &lt;code&gt;configure&lt;/code&gt; 是用来生成配置文件的脚本 ， 运行它会有几个问题 ， 让你回答 ， 回答完后就开始自动安装了 。 也可把这些问答写到一个文件中 ， 让其自动化 。 建立名为 &lt;code&gt;tower_setup_conf.yml&lt;/code&gt;  的文件 ， 其内容为 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;admin_password&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;password&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;database&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;internal&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;munin_password&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;password&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;pg_password&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;password&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;primary_machine&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;localhost&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;redis_password&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;password&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 开始进行设置 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 31 Dec 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-12-31:/install-ansible-tower.html</guid><category>Ansible Tower</category></item><item><title>Ansible安装</title><link>http://xcodest.me/ansible-install.html</link><description>&lt;p&gt; 由于  Ansible  是通过  SSH  进行通讯的 ， 所以只用安装  master  端就可以了 。 并不像  puppet/SaltStack  那样在  slave/minion  端进行安装 。&lt;/p&gt;
&lt;p&gt; 由于是用  Python  编写的 ， 安装起来和普通  Python  应用没有太大区别 。 可以通过源码 ，pypi,  操作系统的包管理进行安装 。&lt;/p&gt;
&lt;h1 id="_1"&gt; 系统包管理 &lt;/h1&gt;
&lt;h2 id="rpm"&gt;RPM  系 &lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# install epel source
yum install -y epel-release
yum install ansible
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="apt"&gt;Apt  系 &lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install -y software-properties-common
apt-add-repository -y ppa:ansible/ansible
apt-get update …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 30 Dec 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-12-30:/ansible-install.html</guid><category>Ansible</category></item><item><title>Deploy Docker Registry Service</title><link>http://xcodest.me/deploy-docker-registry-service.html</link><description>&lt;p&gt; 使用  Docker  时 ， 很多情况下需要搭建自己的  registry  服务 。 把一些私有的  Image  放到上面用 。 官方有一个  registry  的 &lt;a href="https://hub.docker.com/_/registry/"&gt; 镜像 &lt;/a&gt; 可以拉下来 ， 直接用 。 如下 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -p 5000:5000 -v &amp;lt;HOST_DIR&amp;gt;:/tmp/registry-dev registry
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 但是默认没有加上  ssl( 如果没有 ， 只能给本机提供服务 )， proxy 也没有开启 。&lt;/p&gt;
&lt;p&gt; 我自己写了一个  docker compose,  默认开启了以上两个功能 ， 代码见 &lt;a href="https://github.com/jeffrey4l/docker-registry"&gt; 这里 &lt;/a&gt;。 默认使用了  host  的  /data/docker-registry/data  目录做数据  volume,  所以请保证这个目录存在 。&lt;/p&gt;
&lt;p&gt; 使用自己建立的  registry  服务时 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 15 Dec 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-12-15:/deploy-docker-registry-service.html</guid><category>Docker</category></item><item><title>Python Exception init args</title><link>http://xcodest.me/python-exception-init-args.html</link><description>&lt;p&gt;&lt;img alt="Talk is cheep" class="img-responsive" src="/images/talk_is_cheap.jpg"&gt;&lt;/p&gt;
&lt;p&gt; 一直没有搞明白  &lt;code&gt;Exception&lt;/code&gt;  的  args  和  message  参数 ,  最近看了一下  CPython  源码 ，
 终于搞明白了 。&lt;/p&gt;
&lt;p&gt; 一开始 ( 从 2.5 开始 ) 的时候是有  &lt;code&gt;args&lt;/code&gt;  和  &lt;code&gt;message&lt;/code&gt;  两个参数的 。2.6 版本之后 ， 把 
&lt;code&gt;message&lt;/code&gt;  废弃掉了 ， 只留下了一个任意长度的  &lt;code&gt;args&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 以下是 2.5 以后的代码 ， 可以看到 ， 如果 args  长度是 1， 就会把  &lt;code&gt;self.message = args[0]&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;BaseException_new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyTypeObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Fri, 20 Nov 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-11-20:/python-exception-init-args.html</guid><category>Python</category></item><item><title>Interrupt the Python multiprocessing.Pool in graceful way</title><link>http://xcodest.me/interrupt-the-python-multiprocessing-pool-in-graceful-way.html</link><description>&lt;p&gt;When using &lt;code&gt;KeyboardInterrupt&lt;/code&gt;(&lt;code&gt;Ctrl+c&lt;/code&gt;) interrupt the excution of the &lt;code&gt;multiprocess.Pool&lt;/code&gt;, it will not work as expected. Following is a demo&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Pool&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;worker&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;worker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When run the code and try to &lt;code&gt;Ctrl+C …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 17 Nov 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-11-17:/interrupt-the-python-multiprocessing-pool-in-graceful-way.html</guid><category>Python</category></item><item><title>Glance Create Image from Existent Image in Ceph</title><link>http://xcodest.me/glance-create-image-from-existent-image-in-ceph.html</link><description>&lt;p&gt; 当使用  Ceph + Glance  时 ， 镜像需要使用  RAW  格式 ， 这会导致创建镜像时非常的慢 。 有的时候 ， 也需要把  Ceph  中现有的镜像导入到  Glance  中 。 这时可以使用  --location  参数来指定镜像所在的远程位置 。 也就可以使用现有的  Ceph  镜像来快速创建 。&lt;/p&gt;
&lt;p&gt; 可以先用  rbd  上传镜像 ， 转换格式 ( 也会比较慢 ， 还不如直接上传  RAW  格式的镜像 )。 然后再做好对应的  snap ,  并加以保护 。 是后一步的 location 必须按格式写 ( 见 [0])， 这样才会使用 rbd 的  COW clone  功能 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# image format 2 support layering&lt;/span&gt;
rbd --image-format &lt;span class="m"&gt;2 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-06-04:/glance-create-image-from-existent-image-in-ceph.html</guid></item><item><title>Python MetaClass Magic</title><link>http://xcodest.me/python-metaclass-magic.html</link><description>&lt;p&gt; 在  Nova  代码中 [&lt;a href="https://github.com/openstack/nova/blob/c13f693d496f4ea5dbc78244fefd9ec2d6ea8de5/nova/api/openstack/wsgi.py#L1075"&gt;0&lt;/a&gt;] 发现一个神奇的应用 ， 利用  decrator  来区分同名的函数 ， 根据  decrator  上面定义的版本 ， 来调用不同的方法 。 仔细学习了一下 。 它是用到了  MetaClass。 主要思路是 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 在  decrator  里面 ， 把被装饰的方法存在类的一个属性里面 (version_methods)&lt;/li&gt;
&lt;li&gt; 使用自定义的 metaclass,  删除掉父类上的 version_methods， 并把这个属性放到子类中 。 这样做是为了防止子类共享父类的 version_methods 属性 。&lt;/li&gt;
&lt;li&gt; 在子类里面 ， 重写 &lt;code&gt;__getattribute__&lt;/code&gt; 方法 ， 当所需要的属性存在于 &lt;code&gt;version_methods&lt;/code&gt; 时 ， 根据特定的条件 ， 返回期望的方法 。 如果没有 ， 就调用父类的方法 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 以下是示例代码 &lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/0b974aaea1be25cde67d.js?file=version_method.py'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;VERION_METHODS='version_methods'

class VersionMethod(object):
    def __init__(self, version …&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 18 May 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-05-18:/python-metaclass-magic.html</guid><category>Python</category></item><item><title>Oz Templates</title><link>http://xcodest.me/oz-templates.html</link><description>&lt;p&gt; 最近利用 &lt;a href="https://github.com/clalancette/oz"&gt;OZ&lt;/a&gt; 做了几个常用镜像的自动化制作 。 回头有用到的会再加进去 。 说明如下 &lt;/p&gt;
&lt;p&gt; 项目地址 : &lt;a href="https://github.com/jeffrey4l/oz-templates"&gt;https://github.com/jeffrey4l/oz-templates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 以下是 README 里的内容 。&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The isos are located in &lt;code&gt;/data/isos/&lt;/code&gt;. The isos' name are conversionally.
Including&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS-6.3-x86_64-bin-DVD1.iso&lt;/li&gt;
&lt;li&gt;RHEL-6.3-x86_64-DVD.iso&lt;/li&gt;
&lt;li&gt;ubuntu-14.04.1-server-amd64.iso&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/clalancette/oz.git
cd oz
git clone …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 11 May 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-05-11:/oz-templates.html</guid><category>OpenStack</category></item><item><title>论Python的异常的合理抛出姿势</title><link>http://xcodest.me/How_to_raise_python_exception.html</link><description>&lt;p&gt; 当需要重新抛出  Python  的异常时 ， 很多人都处理不好 。 本文总结了一些处理方法 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_cleanup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这种处理会直接把内部异常吃掉 ， 当有问题 /Bug 时 ， 会很难处理 ， 所以不推荐 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_cleanup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
    &lt;span class="c1"&gt;# or&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;traceback&lt;/span&gt;
    &lt;span class="n"&gt;traceback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_exc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这种直接打印的 ， 一是不能很好的输出到日志里 。 二是不能把错误交到上层调用者 ， 不能让其知道这是有问题 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_somethink&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;except&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_cleanup&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;raise&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 用这种 ， 主要是为了做 cleanup。 直接 &lt;code&gt;raise&lt;/code&gt; 后 ， 异常会抛向上层 。 没有 catch 的效果一样 。&lt;/p&gt;
&lt;p&gt; 这里还有一种和上面这个类似的效果的 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;try …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 06 May 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-05-06:/How_to_raise_python_exception.html</guid><category>Python</category><category>Exception</category></item><item><title>Logstash Debug</title><link>http://xcodest.me/logstash_debug.html</link><description>&lt;p&gt;Logstash  能使用  rubydebug  这个  codec  进行  debug。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;input {
    stdin {}
}

output {
    stdout {
        codec =&amp;gt; rubydebug
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 用  logstash  手动启动 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;logstash -f debug.conf --verbose --debug
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 直接输入数据 ， 能得到详细的输出报告 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./logstash -f debug --verbose --debug                            
a
Pipeline started {:level=&amp;gt;:info}
{
       &amp;quot;message&amp;quot; =&amp;gt; &amp;quot;a&amp;quot;,
      &amp;quot;@version&amp;quot; =&amp;gt; &amp;quot;1&amp;quot;,
    &amp;quot;@timestamp&amp;quot; =&amp;gt; &amp;quot;2015-03-23T09:55:15.226Z&amp;quot;,
          &amp;quot;type&amp;quot; =&amp;gt; &amp;quot;test&amp;quot;,
          &amp;quot;host&amp;quot; =&amp;gt; &amp;quot;jeffrey-thinkpad&amp;quot;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="ref"&gt;REF&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://logstash.net/docs/1.4.2/codecs/rubydebug"&gt;http://logstash …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 23 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-03-23:/logstash_debug.html</guid></item><item><title>Nova Security Group相关配置</title><link>http://xcodest.me/nova-security-groupxiang-guan-pei-zhi.html</link><description>&lt;h1 id="_1"&gt; 相关配置 &lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;network_api_class -  设置  network  模块所用的 api&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nova.network.api.API&lt;/code&gt; -  通过 rpc 与 nova-network 交互 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;nova.network.neutronv2.API&lt;/code&gt; -  通过 http 与 neutron-server 交互 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;security_group_api -  设置  security group  模块所用的 api 类 &lt;ul&gt;
&lt;li&gt;&lt;code&gt;nova&lt;/code&gt; (&lt;code&gt;nova.compute.api.SecurityGroupAPI&lt;/code&gt;) -  通过 rcp 与 nova-compute 交互 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;neutron&lt;/code&gt; ( &lt;code&gt;nova.network.security_group.neutron_driver.SecurityGroupAPI&lt;/code&gt; ) -  通过 http 与 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 18 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-03-18:/nova-security-groupxiang-guan-pei-zhi.html</guid><category>Network</category></item><item><title>关于减肥你应该知道的十件事 - 观后总结</title><link>http://xcodest.me/ten-things-you-need-know-abount-loss-weight.html</link><description>&lt;p&gt; 看了 BBC 出的 "BBC： 关于减肥你应该知道的十件事 "， 做了一些笔记 。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 瘦人也可能脂肪高 &lt;ul&gt;
&lt;li&gt; 主要存在于内脏 。 增加有 2 型糖尿病和胰岛素抵抗病的风险 。 内脏脂肪还能释放某些物质损坏心脏周围的动脉 ， 导致心脏病 。 这些物质还能增加癌症的风险 。 肝脏释放的化学物质很容易进入肝脏 ， 影响肝脏清除血液中胰岛素的能力 ， 从而有可能引发 2 型糖尿病 。 减肥时 ， 最先减掉的就是自己内脏里的脂肪 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 不应该减少正餐的次数 。&lt;ul&gt;
&lt;li&gt; 当饥饿时 ， 大脑更偏向于选择高热量的食物 。 当不饿时 ， 大脑会高热量和低热量的食物的反应差不多 。 这是大脑会脑肠肽激素的反应 ， 当胃里排空时 ， 脑肠肽就会向大脑发出信息 ， 进食高热量的食物 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 选用更小的餐具能减少食物的摄入量 。 可以减少 23% 的摄入量 。&lt;/li&gt;
&lt;li&gt; 尽量选用低热量的食物 。 有可能让一天的摄入热量减少 50%。&lt;/li&gt;
&lt;li&gt; 多数人都会低估自己每天的摄入量 ( 大概 50%)。 计算摄入量时 ， 一些看似健康的食物也要加上 。&lt;/li&gt;
&lt;li&gt; 增加蛋白的摄入量能有效的缓解饥饿感 。&lt;ul&gt;
&lt;li&gt; 相比其它的食物 ， 蛋白能够更多的释放酪酪肽 ， 通过血液告诉大脑现在不饿 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 相同的食物 ， 弄成粥羹后食用 ， 会延长胃排空的时间 。&lt;ul&gt;
&lt;li&gt; 因为水会比粥更快的排出胃里 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 12 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-03-12:/ten-things-you-need-know-abount-loss-weight.html</guid></item><item><title>Cinder V2 API</title><link>http://xcodest.me/cinder-v2-api.html</link><description>&lt;p&gt;cinder v2 api add more feature than v1, Like QoS. And the v1 is marked deprecated in juno and will be removed soon. ( may be in kilo).&lt;/p&gt;
&lt;h1 id="enable-the-v2-in-cinder"&gt;Enable the v2 in cinder&lt;/h1&gt;
&lt;p&gt;Change the following config. The v1 and v2 is enabled in default.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# DEPRECATED: Deploy v1 of the Cinder …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 10 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-03-10:/cinder-v2-api.html</guid><category>Cinder</category><category>OpenStack</category></item><item><title>Print the First N Characters of each Line</title><link>http://xcodest.me/print-the-first-n-characters-of-each-line.html</link><description>&lt;p&gt; 在使用  Shell  的过程中 ， 经常会遇到一行过长 ， 导致输出折行 ， 相当难看的情况出现 。 而且多数据情况下 ， 我们只用每行的前  N  个字符就可以了 。 这时可以用以下方法来截断每行的长度 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法 1&lt;/strong&gt;：  使用  &lt;code&gt;awk&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat filename | awk &amp;#39;{print substr($0, 0, 20)}&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt; 方法 2&lt;/strong&gt;:  使用  &lt;code&gt;sed&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat filename | sed &amp;#39;s/\(.\{20\}\).*/\1/&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;  方法 3&lt;/strong&gt;:  使用  &lt;code&gt;sed -r&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat filename | sed -r &amp;#39;s/(.{20}).*/\1/&amp;#39;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Sun, 15 Feb 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-02-15:/print-the-first-n-characters-of-each-line.html</guid><category>Shell</category></item><item><title>修改 Libvirt 的 UUID</title><link>http://xcodest.me/libvirt-uuid.html</link><description>&lt;p&gt; 由于物理机器有限 ， 想做 OpenStack 的多机环境一直是个问题 。 之前是在 OpenStack 上部署 OpenStack。 由于只有一台物理机 ， 资源相当紧张 。 不能建太多机器 。 最近突然想 ， 既然  LXC  现在已经很完善了 。 能不能就利用它来做  OpenStack  服务间的隔离呢 。 所以最近一直在搞这东西 。 搞了几天还是有效果的 。 基本搭建了  OpenStack + Ceph + Swift  的环境出来 。 其中网络用的  Neutron + ML2 + OVS + VLAN。 由于用  LXC  的隔离的 ， 相对于之前来说相当节省资源 。 很好的解决了资源的问题 。 可以做一些大量机器的实验了 。 之后也会也这其中遇到的一些问题写下来 ， 备忘 。&lt;/p&gt;
&lt;p&gt; 今天主要写下配置  Live Migration  过程中遇到的一个问题 。&lt;/p&gt;
&lt;p&gt; 每个  Libvirtd  实例都会有一个  UUID  存在 。 不同的  libvirt  实例的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 10 Feb 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-02-10:/libvirt-uuid.html</guid><category>Libvirt</category></item><item><title>tun &amp; veth设备</title><link>http://xcodest.me/tun-vethshe-bei.html</link><description>&lt;p&gt;OpenStack  的  Neutron  中会建立好多网卡设备 。 大体上这些网卡可以分为两类  tun  和  veth。&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenStack Neutron Network" class="img-responsive" src="/images/neutron-ovs-compute.png"&gt;&lt;/p&gt;
&lt;p&gt; 用 &lt;code&gt;ethtool&lt;/code&gt; 可以得到网卡所用的驱动 ， 从而得到网上设备是哪一类 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ethtool -i veth4NCTQ1 
driver: veth
version: &lt;span class="m"&gt;1&lt;/span&gt;.0
firmware-version: 
bus-info: 
supports-statistics: yes
supports-test: no
supports-eeprom-access: no
supports-register-dump: no
supports-priv-flags: no
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 下面就这两种设备分别做一下介绍 。&lt;/p&gt;
&lt;h1 id="tun-tap"&gt;tun &amp;amp; tap&lt;/h1&gt;
&lt;p&gt;TUN 与 TAP 是操作系统内核中的虚拟网络设备 。 不同于普通靠硬件网路板卡实现的设备 ， 这些虚拟的网络设备全部用软件实现 ， 并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能 。&lt;/p&gt;
&lt;p&gt;TAP  等同于一个以太网设备 ， 它操作第二层数据包如以太网数据帧 。TUN 模拟了网络层设备 ， 操作第三层数据包比如 IP 数据封包 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 09 Feb 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-02-09:/tun-vethshe-bei.html</guid><category>Network</category></item><item><title>中信9积分</title><link>http://xcodest.me/ecitic9.html</link><description>&lt;p&gt; 中信的 i 白金是张好卡 ， 也是我的主力使用卡 。 其中 9 积分的活动还是比较厚道的 。 这个羊毛可以薅一薅 。 但是参加的店和地址还不少 。 我把北京西城这边的统计了一下 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 西树泡芙  - 9 积分换 36 元消费金 1 次 &lt;ul&gt;
&lt;li&gt; 西单北大街 131 号西单大悦城 3F-B14&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 星巴克  - 9 积分兑换大杯手工调制咖啡一杯 &lt;/li&gt;
&lt;li&gt; 哈根达斯  - 9 积分兑换单球冰淇淋 1 个 &lt;ul&gt;
&lt;li&gt; 复兴门内大街 101 号百盛购物中心南楼一层哈根达斯 &lt;/li&gt;
&lt;li&gt; 西单北大街 133 号君太百货一层 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 万宁  - 9 积分 =30 元消费金 &lt;ul&gt;
&lt;li&gt; 阜外大街 2 号北京万通新世界商品批发市场第一层 1A086-1A090、1A100-1A109 号商铺 &lt;/li&gt;
&lt;li&gt; 西单北大街 131 号大悦城 B2-29 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 05 Feb 2015 20:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-02-05:/ecitic9.html</guid></item><item><title>MySQL Errno 150</title><link>http://xcodest.me/mysql-errno-150.html</link><description>&lt;p&gt; 做 OpenStack icehouse  升级到  Juno 过程中 ， 升级 Neutron 数据库时遇到这个错误 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;neutron&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;migration&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;migrate_to_ml2&lt;/span&gt; &lt;span class="n"&gt;openvswitch&lt;/span&gt; &lt;span class="nl"&gt;mysql&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//USER:PASSWORD@10.251.1.8/neutron&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib/python2.7/runpy.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;162&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;_run_module_as_main&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pkg_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib/python2.7/runpy …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 14 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-01-14:/mysql-errno-150.html</guid><category>MySQL</category></item><item><title>PIP install from local</title><link>http://xcodest.me/pip-install-from-local.html</link><description>&lt;p&gt; 在一些特殊环境中 ， 服务器是不能联网的 。 此时要通过 pip 安装包会有一些麻烦 。 这时可以使用 pip 的 download 到本地的功能 ， 来加速安装 。&lt;/p&gt;
&lt;p&gt; 先在有网络的环境中下载下来所有需要的包 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --download &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/.pip-packages -r requirement.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 在把这些包拷贝到目标环境中去 ， 使用下面的命令来安装 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --no-index --find-links &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/.pip-packages -r requirement.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 所有需要的包就安装上了 。&lt;/p&gt;
&lt;p&gt; 为了方便使用 ， 还可以把这两个命令弄成 alias 来使用 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias pipcache=&amp;#39;pip install --download &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/.pip-packages&amp;#39;
alias pipinstall=&amp;#39;pip install --no-index --find-links=file …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 08 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2015-01-08:/pip-install-from-local.html</guid><category>Python</category></item><item><title>Nova flavor init</title><link>http://xcodest.me/nova-flavor-init.html</link><description>&lt;p&gt;ustack 的 flavor 做的还是挺全的 ， 所以用了一个脚本来创建和其一样的 flavor 类型 。&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/ecee9fcb00412cd67fe7.js?file=nova-flavor-init.sh'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;#!/bin/bash
#
# This configuration is copy from ustack.com

DEFAULT_ROOT_GB=40

nova-manage flavor create --name micro-1 --cpu 1 --memory 512 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name micro-2 --cpu 1 --memory 1024 --root_gb $DEFAULT_ROOT_GB --is_public True

nova-manage flavor create --name standard-1 --cpu …&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 11 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-09-11:/nova-flavor-init.html</guid><category>OpenStack</category><category>Nova</category></item><item><title>Python cString raise exception when feed Unicode</title><link>http://xcodest.me/python-cstring-unicode.html</link><description>&lt;p&gt;I gett following different result when using these two Class.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;StringIO&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cStringIO&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;StringIO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StringIO&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;u&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\u2222&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cStringIO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StringIO&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;u&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\u2222&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="ne"&gt;UnicodeEncodeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t encode character u&amp;#39;&lt;/span&gt;\&lt;span class="n"&gt;u2222&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; in position 0: ordinal not in …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 09 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-09-09:/python-cstring-unicode.html</guid><category>Python</category></item><item><title>Migrate SVN to GitLab</title><link>http://xcodest.me/migrate-svn-to-gitlab.html</link><description>&lt;ul&gt;
&lt;li&gt; 在 GitLab 上创建相对应的项目 / 项目组 &lt;/li&gt;
&lt;li&gt; 准备 ''users.txt'' 文件 ， 来修正提交用户名 。 并手动修改 users.txt 的正确性  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;svn log &amp;lt;svn-url&amp;gt; --xml | grep -P &amp;quot;^&amp;lt;author&amp;quot; | sort -u | perl -pe &amp;#39;s/&amp;lt;author&amp;gt;(.*?)&amp;lt;\/author&amp;gt;/$1 = /&amp;#39; &amp;gt; users.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;users.txt 的文件格式如下 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Lei Zhang = Lei Zhang &amp;lt;zhang.lei.fly#gmail.com&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt; 把 SVN 项目使用 git-svn 进行克隆  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git svn clone …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 12 Aug 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-08-12:/migrate-svn-to-gitlab.html</guid><category>Git</category></item><item><title>硬派健身-减肥篇 阅读笔记</title><link>http://xcodest.me/hard-gym-reading-note.html</link><description>&lt;h2 id="_1"&gt; 战肥肉有氧不敌 ， 强塑身无氧超神 &lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt; 长时间有氧运动 —— 似是而非的减肥妙计 &lt;ol&gt;
&lt;li&gt; 当我们的身体状态稳定 ， 身体素质 、 生活习惯变化不大时 ， 我们的体重和体脂含量都是只能加 ， 不能减 ， 只能胖 ， 不能瘦 。 这就是我们序章介绍过的体重设定点理论 。&lt;/li&gt;
&lt;li&gt; 很多实验都证实 ， 单纯增加能量支出 ， 做长时间 、 中高强度的有氧运动 ， 无法有效地帮正常人减重 。&lt;/li&gt;
&lt;li&gt; 你的身体也是一样 ， 当它打定主意把你的体重维持在一个设定点上 ， 就会有非常多的手段可以调节这些体重和脂肪 。 比如 ， 瘦素是一种能减肥和帮助我们抑制食欲的身体激素 。 研究发现 ， 如果我们单纯进行长时间有氧耐力运动减肥 ， 增加了热量的支出 ， 我们身体会减少瘦素的分泌 ， 让我们多吃 ， 多增长脂肪 。 效果可以持续好几天 ，&lt;/li&gt;
&lt;li&gt; 还有研究发现 ， 马拉松运动员的瘦素分泌量仅为普通人的三分之一 。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 共振 —— 跑步会伤害胖胖的你 ……&lt;ol&gt;
&lt;li&gt; 这也就是说 ， 跑步等运动会在脂肪和关节等部位引起共振 ， 共振的效应最后会引起身体与关节的损伤 。 目前的研究发现 ， 脂肪的体积越大 ， 重量越重 ， 共振的效果越强 ， 对身体的伤害也就越强烈 。 冲击力的输入振动频率是 10hz 左右 ， 脂肪的固定振动频率是 2-10hz， 可以引起共振 ， 伤害到自己的身体组织 &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 世上减肥万法 ， 唯有肌肉无敌 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-07-19:/hard-gym-reading-note.html</guid><category>Book</category></item><item><title>Glance Image Cache</title><link>http://xcodest.me/glance-image-cache.html</link><description>&lt;p&gt;Glance  增加了一层 cache 的 Middleware， 用来缓存从 file store 后端取过来的镜像 。 一定 
 程度上可以加快取镜像的速度 。 这个功能默认情况下是没开启的 。&lt;/p&gt;
&lt;p&gt; 因为是通过 middleware 来控制的 ， 所以只要修改一下 paster 的配置就行 。 更简单的是指定 
glance-api 加载的 pipeline 的名字 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[deploy]&lt;/span&gt;
&lt;span class="c1"&gt;# possible value: none, cachine, keystone, keystone+caching, &lt;/span&gt;
&lt;span class="c1"&gt;# keystone+cachemanagement&lt;/span&gt;
&lt;span class="c1"&gt;# This value can get from glance-api-paste.conf file&lt;/span&gt;
&lt;span class="na"&gt;flavor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;keystone+caching&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 具体看下 &lt;code&gt;glance-api-paster.conf&lt;/code&gt; 文件就能明白 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[pipeline:glance-api …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-07-17:/glance-image-cache.html</guid><category>Glance</category></item><item><title>Salt Mine</title><link>http://xcodest.me/salt-mine.html</link><description>&lt;p&gt;Salt mine  可以在一定的控制内让 minion 拿到其它 minion 的信息 。 实现原理是 ： 通过配置 ， 让 minion 定期 ( 最短为 1 分钟 ) 的向 master 发送数据 ， 而其它 minion 可以从 master 拿到这些数据 。 一定程度上实现的 minion 之间的通迅 。 在搭建 cluster 时 ， 十分有用 。&lt;/p&gt;
&lt;p&gt; 可以通过两种方法来配置 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;minion 的配置文件 &lt;/li&gt;
&lt;li&gt;master 的 pillar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 使用 minion 配置时 ， 要直接修改 minion 的配置文件 ， 在 &lt;code&gt;/etc/salt/minion.d/mine.conf&lt;/code&gt;  加入如下内容 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Wed, 16 Jul 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-07-16:/salt-mine.html</guid><category>SaltStack</category></item><item><title>linux bonding mode 6 break the vms</title><link>http://xcodest.me/linux-bonding-mode-6-break-the-vms.html</link><description>&lt;p&gt; 操作系统 ： ubuntu 12.04.1
 内核  linux 3.2&lt;/p&gt;
&lt;p&gt; 今天发现一个网络上的问题 ， 如果  Openstack Fixed IP  走  mode 6  绑定的网卡 ， 不同物理机上的虚拟机是相互访问不了的 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    +---- host1 -------+         +---- host2 ----+
                     eth0 ---- eth0 
                   /                \
    br1 ---- bond0                   bond0 ---- br1 
                   \                /
                     eth0 ---- eth0 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 机器的连接方式如上图 ， 经检查发现 ， 问题简化成两边的  br1  是不通的 ， 现像是 ping 时 ， 接收方收不到包 ， 包只走到 bond0 就给丢弃了 。 原因在于内核上有问题 。 在网络上查到以下两个连接  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;https://bugs.launchpad.net/ubuntu/+source/linux …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 14 Apr 2014 19:39:51 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2014-04-14:/linux-bonding-mode-6-break-the-vms.html</guid><category>Network</category></item><item><title>Dhcp lease errors in vlan mode</title><link>http://xcodest.me/dhcp-lease-errors-in-vlan-mode.html</link><description>&lt;p&gt; 在使用 &lt;code&gt;keepalived&lt;/code&gt; 的过程中 ， 出现了 dhcp 失败 ， 而导致 keepalived 工作不正常的问题 。 而且之前也出现过 dhcp 偶尔失败 ， 导致虚拟机不能得到 IP,  从而不能访问的情况 。 虽然在 &lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt; 中加上了如下语句 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;PERSISTENT_DHCLIENT=1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 使得 dhcp 单次失败后 ， 继续重试 。 但是仔细查看 dhclient 的日志后 ， 发现它有大量的 dhcp request 失败 / 超时 。 在一个 &lt;a href="http://openstack.markmail.org/search/?q=Dhcp+lease+errors+in+vlan+mode#query:Dhcp%20lease%20errors%20in%20vlan%20mode+page:1+mid:7kjf4hljszpydsrx+state:results"&gt; 邮件列表 &lt;/a&gt; 中找到原因 ， 如下 ：&lt;/p&gt;
&lt;p&gt;To fix issues with failed dhcp leases in vlan mode, upgrade …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Tue, 27 Aug 2013 08:50:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2013-08-27:/dhcp-lease-errors-in-vlan-mode.html</guid><category>DHCP</category><category>Network</category><category>VLAN</category></item><item><title>Openstack Brief</title><link>http://xcodest.me/openstack-brief.html</link><description>&lt;p&gt; 自从 Openstack 诞生之日起 ， 就受到越来越多的开发者 ， 用户的关注 。 整个代码的规模和质量正在飞速的发展 。 随着各种功能的增加 ，Openstack 下面已经拥有了相当多子项目 ， 来完成各种各样的功能 。 本文将简单介绍各个子项目的功能和发展 。 所有的项目现状是基于 Grizzly 的版本来写的 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keystone&lt;/li&gt;
&lt;li&gt;Nova&lt;/li&gt;
&lt;li&gt;Cinder&lt;/li&gt;
&lt;li&gt;Glance&lt;/li&gt;
&lt;li&gt;Openstack Network(Quantum)&lt;/li&gt;
&lt;li&gt;LBaaS&lt;/li&gt;
&lt;li&gt;Ceilometer&lt;/li&gt;
&lt;li&gt;Baremetal&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="keystone"&gt;Keystone&lt;/h1&gt;
&lt;p&gt;keystone 是 Openstack 的认证和服务注册模块 。 其结构比较简单 。 其功能包括 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt; 认证 &lt;/strong&gt;  主要功能是管理用户和用户组的信息 ， 后端可以绑定 ldap, mysql 等认证方式 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 服务注册模块 &lt;/strong&gt;  主要用于管理 Openstack 相关服务的地址 ， 所有的服务都要先注册到 Keystone 中 ， 才可以使用 。 它可使用基于文件的模板 ， 也可以使用数据库存储 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Token&lt;/strong&gt;  管理 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 相对于其它子项目来说 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeffrey4l</dc:creator><pubDate>Mon, 17 Jun 2013 23:08:00 +0800</pubDate><guid isPermaLink="false">tag:xcodest.me,2013-06-17:/openstack-brief.html</guid></item></channel></rss>