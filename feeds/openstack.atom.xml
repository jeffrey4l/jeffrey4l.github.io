<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Xcodest</title><link href="http://xcodest.me/" rel="alternate"></link><link href="http://xcodest.me/feeds/openstack.atom.xml" rel="self"></link><id>http://xcodest.me/</id><updated>2016-02-24T00:00:00+08:00</updated><entry><title>OpenStack Kolla AIO Install</title><link href="http://xcodest.me/kolla-aio-install.html" rel="alternate"></link><updated>2016-02-24T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-02-24:kolla-aio-install.html</id><summary type="html">
&lt;p&gt;Kolla 依赖于以下几个主要组件 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible &amp;gt; 1.9.4, &amp;lt; 2.0&lt;/li&gt;
&lt;li&gt;Docker &amp;gt; 1.10.0&lt;/li&gt;
&lt;li&gt;docker-py &amp;gt; 1.7.0&lt;/li&gt;
&lt;li&gt;python jinja2 &amp;gt; 2.6.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 几点说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 机器使用的是 kvm 虚拟机进行的测试。配置上使用 4G RAM, 2 CPU, 2 网卡的配置 &lt;/li&gt;
&lt;li&gt; 由于使用了 Docker，所以对于底层系统并还没什么要求，本文使用 CentOS 7 系统。&lt;/li&gt;
&lt;li&gt;Kolla master 分支上使用的是 RDO master 上的源，打包极不稳定，时常会有 Bug 出现。所以本文使用的是 CentOS + 源码的安装方式 &lt;/li&gt;
&lt;li&gt; 由于国内网络原因，一些国外的源 ( 这些源还没有国内镜像 ) 会相当慢，所以 build docker image 时会很慢，推荐使用 VPN&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt; 安装 &lt;/h1&gt;
&lt;p&gt; 安装好操作系统后，依次进行如下配置 &lt;/p&gt;
&lt;h2 id="_2"&gt; 源 &lt;/h2&gt;
&lt;p&gt; 加入 Docker 的源 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;sudo tee /etc/yum.repos.d/docker.repo &amp;lt;&amp;lt; 'EOF'&lt;/span&gt;
&lt;span class="x"&gt;[dockerrepo]&lt;/span&gt;
&lt;span class="x"&gt;name=Docker Repository&lt;/span&gt;
&lt;span class="x"&gt;baseurl=https://yum.dockerproject.org/repo/main/centos/&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;releasever&lt;/span&gt;&lt;span class="x"&gt;/&lt;/span&gt;
&lt;span class="x"&gt;enabled=1&lt;/span&gt;
&lt;span class="x"&gt;gpgcheck=1&lt;/span&gt;
&lt;span class="x"&gt;gpgkey=https://yum.dockerproject.org/gpg&lt;/span&gt;
&lt;span class="x"&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 加入 EPEL 源 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install -y epel-release
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="kolla"&gt; 安装 Kolla 所需依赖 &lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install -y ansible docker-engine git gcc python-setuptools
easy_install -U pip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Docker 现在使用了 shared mount 功能，默认没有打开，需要手动修改 Docker 启动文件 &lt;code&gt;/usr/lib/systemd/system/docker.service&lt;/code&gt; 的 MountFlags&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -i 's/MountFlags.*/MountFlags=shared/' /usr/lib/systemd/system/docker.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 启动 Docker 服务 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;systemctl daemon-reload
systemctl enable docker
systemctl start docker
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="kolla_1"&gt; 下载 Kolla 代码并安装依赖 &lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/openstack/kolla.git
cd kolla
pip install -r requirements.txt -r test-requirements.txt tox
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="build-docker-image"&gt;Build Docker Image&lt;/h1&gt;
&lt;p&gt; 以下如果没有特别说明，所有的操作都是在 Kolla 项目的目录里进行 &lt;/p&gt;
&lt;p&gt; 首先要先生成并修改配置文件 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tox -e genconfig
cp -rv etc/kolla /etc/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后修改 &lt;code&gt;/etc/kolla/kolla-build.conf&lt;/code&gt; 文件，它是用来控制 kolla build 过程的。修改后，其主要内容如下 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[DEFAULT]&lt;/span&gt;
&lt;span class="na"&gt;base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;centos&lt;/span&gt;
&lt;span class="na"&gt;install_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;soruce&lt;/span&gt;
&lt;span class="na"&gt;namespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;lokolla&lt;/span&gt;
&lt;span class="na"&gt;push&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接下来就是进行漫长的 build, 这个过程主要依赖机器性能和网速。如果快的话，20 多分钟就完成。如果有问题的话，会很久。不过依赖于 Docker Build 的 Cache 功能，就算重跑的话，之前已经 Build 好的也会很快完成。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./tool/build.py -p default
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 参数中的 &lt;code&gt;-p default&lt;/code&gt; 是指定了只 build 主要的 image, 包括 : mariadb, rabbitmq, cinder, ceilometer, glance, heat, horizon, keystone, neutron, nova, swift 等 . 这些可以只生成的 &lt;code&gt;kolla-build.conf&lt;/code&gt; 里找到。&lt;/p&gt;
&lt;p&gt; 如果 Build 完成之后，使用 &lt;code&gt;docker images&lt;/code&gt; 能看到所有已经 build 好的镜像。&lt;/p&gt;
&lt;h1 id="deploy"&gt;Deploy&lt;/h1&gt;
&lt;p&gt; 依然是先修改配置文件，与 Deploy 相关的主要是两个配置文件 &lt;code&gt;/etc/kolla/passwords.yml&lt;/code&gt; 和 &lt;code&gt;/etc/kolla/globals.yml&lt;/code&gt;。他们为 ansible 提供一些变量的设定。主要需要修改的是 &lt;code&gt;globals.yml&lt;/code&gt; 文件。修改后，其主要内容为 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;config_strategy&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"COPY_ALWAYS"&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;kolla_base_distro&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"centos"&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;kolla_install_type&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"source"&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;kolla_internal_address&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"10.2.0.254"&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;network_interface&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"eth0"&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;neutron_external_interface&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"eth1"&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;openstack_logging_debug&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"true"&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;enable_cinder&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"no"&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;enable_heat&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"no"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kolla 使用一个名为 &lt;code&gt;kolla-ansible&lt;/code&gt; 的封装脚本， 并提供以下几个命令 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./tools/kolla-ansible -h
Usage: ./tools/kolla-ansible COMMAND [options]

Options:
    --inventory, -i &amp;lt;inventory_path&amp;gt; Specify path to ansible inventory file
    --playbook, -p &amp;lt;playbook_path&amp;gt;   Specify path to ansible playbook file
    --keyfile, -k &amp;lt;key_file&amp;gt;         Specify path to ansible vault keyfile
    --help, -h                       Show this usage information
    --tags, -t &amp;lt;tags&amp;gt;                Only run plays and tasks tagged with these values

Commands:
    prechecks    Do pre-deployment checks for hosts
    deploy       Deploy and start all kolla containers
    post-deploy  Do post deploy on deploy node
    pull         Pull all images for containers (only pulls, no runnnig container changes)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以使用 &lt;code&gt;./tools/kolla-ansible prechecks&lt;/code&gt; 来检查一个机器是否满足安装条件。&lt;/p&gt;
&lt;p&gt; 使用 &lt;code&gt;./tools/kolla-ansible deploy&lt;/code&gt; 来开始正式安装。安装会很快，我机器上，几分钟就安装完成了。&lt;/p&gt;
&lt;p&gt; 最后，使用 &lt;code&gt;./tools/kolla-ansible post-deploy&lt;/code&gt; 来生成 &lt;code&gt;/etc/kolla/admin-openrc.sh&lt;/code&gt; 文件用来加载认证变量。&lt;/p&gt;
&lt;h1 id="_3"&gt; 查看安装后的状态 &lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;IMAGE                                                  COMMAND                 NAMES
lokolla/centos-source-keystone:2.0.0                   "kolla_start"           keystone
lokolla/centos-source-horizon:2.0.0                    "kolla_start"           horizon
lokolla/centos-source-neutron-metadata-agent:2.0.0     "kolla_start"           neutron_metadata_agent
lokolla/centos-source-neutron-l3-agent:2.0.0           "kolla_start"           neutron_l3_agent
lokolla/centos-source-neutron-dhcp-agent:2.0.0         "kolla_start"           neutron_dhcp_agent
lokolla/centos-source-neutron-openvswitch-agent:2.0.0  "kolla_start"           neutron_openvswitch_agent
lokolla/centos-source-neutron-server:2.0.0             "kolla_start"           neutron_server
lokolla/centos-source-openvswitch-vswitchd:2.0.0       "kolla_start"           openvswitch_vswitchd
lokolla/centos-source-openvswitch-db-server:2.0.0      "kolla_start"           openvswitch_db
lokolla/centos-source-nova-compute:2.0.0               "kolla_start"           nova_compute
lokolla/centos-source-nova-libvirt:2.0.0               "kolla_start"           nova_libvirt
lokolla/centos-source-nova-conductor:2.0.0             "kolla_start"           nova_conductor
lokolla/centos-source-nova-scheduler:2.0.0             "kolla_start"           nova_scheduler
lokolla/centos-source-nova-novncproxy:2.0.0            "kolla_start"           nova_novncproxy
lokolla/centos-source-nova-consoleauth:2.0.0           "kolla_start"           nova_consoleauth
lokolla/centos-source-nova-api:2.0.0                   "kolla_start"           nova_api
lokolla/centos-source-glance-api:2.0.0                 "kolla_start"           glance_api
lokolla/centos-source-glance-registry:2.0.0            "kolla_start"           glance_registry
lokolla/centos-source-rabbitmq:2.0.0                   "kolla_start"           rabbitmq
lokolla/centos-source-mariadb:2.0.0                    "kolla_start"           mariadb
lokolla/centos-source-memcached:2.0.0                  "kolla_start"           memcached
lokolla/centos-source-keepalived:2.0.0                 "kolla_start"           keepalived
lokolla/centos-source-haproxy:2.0.0                    "kolla_start"           haproxy
lokolla/centos-source-kolla-toolbox:2.0.0              "/bin/sleep infinity"   kolla_toolbox
lokolla/centos-source-heka:2.0.0                       "kolla_start"           heka
lokolla/centos-source-rsyslog:2.0.0                    "kolla_start"           rsyslog
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 为了显示好看，我去掉了一些无关的列。通过上面，可以看出 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 多数 container 里是由 kolla_start 这个脚本启动起来的 &lt;/li&gt;
&lt;li&gt; 由于 kolla 使用的是 &lt;code&gt;--net=host&lt;/code&gt; 网络，所以没有必要做端口映射 &lt;/li&gt;
&lt;li&gt; 每个模块拆分成了多个 container, 如 nova 被拆分成了 nova_api, nova_libvirt, nova_conductor, nova_novncproxy, nova_compute 等多个 container。很好的遵守了一个容器一个进程的原则。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Kolla"></category><category term="OpenStack"></category></entry><entry><title>Kolla Mitaka Midcycle Discuss</title><link href="http://xcodest.me/kolla-mitaka-midcycle-discuss.html" rel="alternate"></link><updated>2016-02-16T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-02-16:kolla-mitaka-midcycle-discuss.html</id><summary type="html">
&lt;p&gt;2016 年 2 月 9 日 -10 日，Kolla Team 举办了 Mitaka 的中期会议，对遇到的问题、解决的方法及接下来的工作内容做了深入讨论。&lt;/p&gt;
&lt;h1 id="_1"&gt; 讨论的优先级安排 &lt;/h1&gt;
&lt;p&gt; 首先对本次讨论进行了优先级安排 &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upgrades： 这是现在的重中之重。如何能对现有的 Kolla 进行平滑的升级。包括 OpenStack 组件和基础服务组件 ( 如 MariaDB 等 )。&lt;/li&gt;
&lt;li&gt;diagnostics/logging: 主要是指 ELK。&lt;/li&gt;
&lt;li&gt;stability of deployment&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;backwards compatibility&lt;/li&gt;
&lt;li&gt;selinux&lt;/li&gt;
&lt;li&gt;kolla-ansible split&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="upgrade"&gt;Upgrade&lt;/h1&gt;
&lt;p&gt; 升级主要涉及到两部分。相关的 BP 在这里 &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 是 OpenStack 的各个组件 &lt;/li&gt;
&lt;li&gt; 是一些基础服务组件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="openstack"&gt;OpenStack 组件 &lt;/h2&gt;
&lt;p&gt; 由于 OpenStack 各个组件的结构基本相同，都是有 DB, API, Scheduler 等几个部分构成。所以这里的升级要简单一些，而且已经基本完成了编码工作，不过需要大量的测试来保证升级的可靠性 &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h2 id="_2"&gt; 基础服务组件 &lt;/h2&gt;
&lt;p&gt; 由于各个组件的升级方式并不同，同一个组件不同版本间，可能也不相同。所以这部分相比较来说要困难的多。讨论中对各个组件进行了逐一讨论。包括升级的方式，有可能造成的影响等。详细信息见 &lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h1 id="diagnosticslogging"&gt;Diagnostics/Logging&lt;/h1&gt;
&lt;h1 id="security"&gt;Security&lt;/h1&gt;
&lt;p&gt; 安全也是很重要的事情，Team 两次讨论了这个问题 &lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;sup id="fnref:8"&gt;&lt;a class="footnote-ref" href="#fn:8" rel="footnote"&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt; 在各个模块之前开启 SSL 功能 &lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;。当然默认是通过配置开启的。这样使 OpenStack 运行在一个更加安全的环境中。这个功能期望是在 Mitaka-3 中完成。&lt;/p&gt;
&lt;p&gt; 容器中的安全 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 使用非 root 用户运行服务 &lt;/li&gt;
&lt;li&gt;Container 内，配置文件是否能被修改 &lt;/li&gt;
&lt;li&gt;rootwrap 不应该能修改 &lt;/li&gt;
&lt;li&gt; 开启 SELinux &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="backport"&gt;Backport&lt;/h1&gt;
&lt;p&gt;Liberty 是 Kolla Release 的第一个版本。而在现在的 Master 分支中，已经有了大量的新功能。Team 讨论了 Backport 的原因和意义 &lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt; 最主要的原因 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible 的 docker 模块有 bug, 导致 ansible 与 1.8.2 以上的 docker 版本不兼容 &lt;/li&gt;
&lt;li&gt;docker 1.9 后的 named volume 功能很好的解决了 &lt;ol&gt;
&lt;li&gt; 可能出现在数据丢失。在使用 data container 时，如果 Base Image 发生改变，data container 也会被重新创建，从而造成数据丢失。&lt;/li&gt;
&lt;li&gt; 可能造成短时间的网络不可用。原因也是 data container 里面创建的 namespace 会被删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 解决方法有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 直接把 stable/liberty 分支移动到 master 的位置。但是个人感觉不靠谱。&lt;/li&gt;
&lt;li&gt; 把所有的 commmit squash 后提交到 stable/liberty 分支上 &lt;/li&gt;
&lt;li&gt;stable/liberty 和 master 做一次 merge。&lt;/li&gt;
&lt;li&gt; 只 backport kolla_docker module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 现在看来，应该会采取方法 4。&lt;/p&gt;
&lt;h1 id="kolla-code-sharing"&gt;kolla code sharing&lt;/h1&gt;
&lt;p&gt; 现在 Kolla 相关的项目有两个 https://github.com/openstack/kolla 和 https://github.com/openstack/kolla-mesos 。将来还会分拆出一个 kolla-ansible 项目来。现在， 单这两个项目下就有很多的重复代码，导致做了许多 copy, paster 的工作。这个 topic&lt;sup id="fnref:9"&gt;&lt;a class="footnote-ref" href="#fn:9" rel="footnote"&gt;9&lt;/a&gt;&lt;/sup&gt; 就是来解决这个问题的。&lt;/p&gt;
&lt;p&gt; 重复的东西 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;extend_start.sh 在两个仓库中有很多重复的 &lt;/li&gt;
&lt;li&gt;kolla_docker 等 ansible 模块 &lt;/li&gt;
&lt;li&gt; 很多 config 里面的定义 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 可能的解决方法包括 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 定期的把 &lt;code&gt;&amp;lt;kolla&amp;gt;/ansible&lt;/code&gt; 下的模板复制到 kolla-mesos 中 &lt;/li&gt;
&lt;li&gt; 两连都存在副本，定期进行双向的同步。&lt;/li&gt;
&lt;li&gt; 创新一个新的仓库包含一些共用的模板 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="roadmap"&gt;Roadmap&lt;/h1&gt;
&lt;p&gt;Mitaka, Netron, Ocata， P 版本的功路线图 &lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="#fn:7" rel="footnote"&gt;7&lt;/a&gt;&lt;/sup&gt;。你更期待什么功能呢 ?&lt;/p&gt;
&lt;h2 id="mitaka-3-roadmap"&gt;Mitaka-3 Roadmap&lt;/h2&gt;
&lt;p&gt;Mitaka 进入最后的阶段，还有一些重要功能在开发中，现在主要还有以下几点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;diagnostics&lt;/li&gt;
&lt;li&gt;reconfigure services on a redeploy&lt;/li&gt;
&lt;li&gt;infrastructure services upgrades such as mariadb&lt;/li&gt;
&lt;li&gt;migration path for data volumes&lt;/li&gt;
&lt;li&gt;functional tests in gate (boot a vm &amp;amp; ping test)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="newton-roadmap"&gt;Newton Roadmap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;voting gates&lt;/li&gt;
&lt;li&gt;jumbo frames MTU investigation&lt;/li&gt;
&lt;li&gt;kolla as replacement of devstack (bindmount sources etc)&lt;/li&gt;
&lt;li&gt;code dedupe between mesos/ansible (general templates)&lt;/li&gt;
&lt;li&gt;ansible 2.0+&lt;/li&gt;
&lt;li&gt;conditionalize docs&lt;/li&gt;
&lt;li&gt;selinux&lt;/li&gt;
&lt;li&gt;more functional tests in gates (mitaka will have boot an vm)&lt;/li&gt;
&lt;li&gt;documentation specifically operator guides&lt;/li&gt;
&lt;li&gt;network isolation documentation&lt;/li&gt;
&lt;li&gt;multinode gates&lt;/li&gt;
&lt;li&gt;mechanism to build/push stable images to dockerhub&lt;ul&gt;
&lt;li&gt;push per tag&lt;/li&gt;
&lt;li&gt;nightly push&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;kolla-ansible split right at start of newton split the repos&lt;/li&gt;
&lt;li&gt;hot-reload of running config for openstack service&lt;/li&gt;
&lt;li&gt;Python API with no running services for managing Kolla&lt;/li&gt;
&lt;li&gt;BiFrost documentation and investigation&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="ocata-roadmap"&gt;Ocata Roadmap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;deploy full big tent (or develop plugin mechanism to deploy whatever) / maybe we could do a skeleton service&lt;/li&gt;
&lt;li&gt;kolla-saltstack, kolla-puppet investigation - may not even be needed when moving to Ansible 2.0&lt;/li&gt;
&lt;li&gt;horizon, neutron, and nova plugin support - this exists already? would like to do in Newton but not have bandwidth&lt;/li&gt;
&lt;li&gt;Monitoring&lt;/li&gt;
&lt;li&gt;Backup and Restore of OpenStack data&lt;/li&gt;
&lt;li&gt;Data caching (e.g. redis)&lt;/li&gt;
&lt;li&gt;kolla-kubernetes&lt;/li&gt;
&lt;li&gt;runc investigation&lt;/li&gt;
&lt;li&gt;rkt investigation&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="p-roadmap"&gt;P Roadmap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;rollback support from upgrade&lt;/li&gt;
&lt;li&gt;canary deployment&lt;/li&gt;
&lt;li&gt;make Kolla operate optionally without net=host for upcoming kolla-mesos and kolla-kubernetes repositories&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="ref"&gt;REF&lt;/h1&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-priorities"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-priorities&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-upgrades"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-upgrades&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;&lt;a href="https://blueprints.launchpad.net/kolla?searchtext=upgrade"&gt;https://blueprints.launchpad.net/kolla?searchtext=upgrade&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-infrastructure-upgrades"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-infrastructure-upgrades&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-ssl"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-ssl&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-backport"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-backport&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-roadmap"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-roadmap&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:8"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-security"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-security&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:8" rev="footnote" title="Jump back to footnote 8 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:9"&gt;
&lt;p&gt;&lt;a href="https://etherpad.openstack.org/p/kolla-mitaka-midcycle-kolla-code-sharing"&gt;https://etherpad.openstack.org/p/kolla-mitaka-midcycle-kolla-code-sharing&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:9" rev="footnote" title="Jump back to footnote 9 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Kolla"></category></entry><entry><title>OpenStack Kolla 项目介绍</title><link href="http://xcodest.me/kolla-introduce.html" rel="alternate"></link><updated>2016-01-11T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-01-11:kolla-introduce.html</id><summary type="html">
&lt;h1 id="_1"&gt; 项目目标 &lt;/h1&gt;
&lt;p&gt;Kolla 提供了生产级别的 OpenStack Service Containers。基于社区的最佳实践，提供了
更好，更快，更可靠的 , 操作 OpenStack 的部署工具。&lt;/p&gt;
&lt;h1 id="_2"&gt; 解决的问题 &lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt; 平滑的升级 / 回滚 OpenStack&lt;/li&gt;
&lt;li&gt; 隔离 OpenStack 的不同组件的依赖环境。尤其是那些使用同一模块不同版本的情况。&lt;/li&gt;
&lt;li&gt; 保证环境的一致性。解决由于安装时间不同，造成的包版本不一致的情况。&lt;/li&gt;
&lt;li&gt; 支持多种安装源：源代码安装，CentOS binary 安装等。可以替代掉 devstack。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 其实这些问题只要是由 Docker 来解决的。这也是 Kolla 使用 Docker 的原因。&lt;/p&gt;
&lt;h1 id="_3"&gt; 架构 &lt;/h1&gt;
&lt;p&gt;kolla 代码在 &lt;a href="https://github.com/openstack/kolla"&gt;https://github.com/openstack/kolla&lt;/a&gt;。现在 Kolla 主要分成两个部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker Images Build &lt;/li&gt;
&lt;li&gt;Ansible 部署 ( 这部分将来会迁移到 kolla-ansible 项目 )&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="docker-image-build"&gt;Docker Image Build&lt;/h2&gt;
&lt;p&gt; 主要使用 Jinja2 模板生成 Dockerfile 文件。如果是源代码安装，还会把代码下载好。之后会通过 Docker-py 驱动 Docker 进行镜像构建。构建完成，还可以根据配置将镜像推送的指定的 Registry 服务器。&lt;/p&gt;
&lt;p&gt; 现在支持的不同的 Linux 发行版本 (Redhat 系和 Debian 系 ) 和不同的 OpenStack 安装包 ( 源代码和二进制包 )&lt;/p&gt;
&lt;p&gt; 下图是现在所有镜像的依赖关系。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Kolla Image Dependency Tree" class="img-responsive" src="images/kolla/image-dependency-201512.png"/&gt;&lt;/p&gt;
&lt;h2 id="ansible"&gt;Ansible 部署 &lt;/h2&gt;
&lt;p&gt; 提供一个完整的 Ansible Playbook，来部署 Docker 的镜像。并提供 all-in-one 和
multihost 的环境 &lt;/p&gt;
&lt;h1 id="_4"&gt; 开发人员情况 &lt;/h1&gt;
&lt;p&gt; 以下是 Kolla 项目截至到 2016-01-20 日的 review, commit 情况 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Kolla Review 20160120" class="img-responsive" src="images/kolla/kolla_review_stackalytics_20160120.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Kolla Commit 20160120" class="img-responsive" src="images/kolla/kolla_commit_stackalytics_20160120.png"/&gt;&lt;/p&gt;
&lt;p&gt; 可以看出，主流的几大 OpenStack 厂商均贡献的大部分的代码。包括 Mirantis, RedHat, Oracle, Intel, 99Cloud, Cisco, Rakespace。&lt;/p&gt;
&lt;h1 id="_5"&gt; 近况 &lt;/h1&gt;
&lt;h2 id="201512"&gt;201512&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt; 废弃使用 Ansible 自带的 Docker module。使用自己实现的 docker 模块 &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, 并已经完成了所有 ansible roles 的改造。主要原因是：&lt;ol&gt;
&lt;li&gt; 官方 Docker module 有 bug&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;, 在 docker 1.8.3 及以上的版本工作不正常 , 而且进展缓慢。而 Kolla 使用的 Docker 版本只能锁定在 1.8.2，不能进行升级。&lt;/li&gt;
&lt;li&gt;Ansible 使用的是 GPL，而 OpenStack 项目使用的 Apache License。不能直接修改 Ansible 的代码放到 Kolla 里使用。&lt;/li&gt;
&lt;li&gt; 不想受限制于官方功能开发。有些想用的功能 ( 比方说新加进去的 &lt;code&gt;common_option&lt;/code&gt;, 官方是不会增加的 )。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 使用 oslo.config 模块替代掉了原来的 argparser 代码 &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;。并加上了使用 &lt;code&gt;oslo-config-generator&lt;/code&gt; 的功能自动生成配置文件。&lt;/li&gt;
&lt;li&gt; 完善 Ubuntu Binary Container 的安装 &lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="#fn:7" rel="footnote"&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;ul&gt;
&lt;li&gt; 由于 Ubuntu 并没有类似 RDO 的 relorean 源。倒是有一个 Mitaka Staging&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt; 源，但是好久没有更新。所以社区之前一直没有加上这部分功能。现在虽然加上了，但是也是基于 Liberty 版本的。并不是 Master 上的代码。&lt;/li&gt;
&lt;li&gt; 另一方面，Ubuntu 方面也正在积极的解决这个问题 &lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;。相信不久就会有。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 升级的 playbook 基本完成来 &lt;sup id="fnref:8"&gt;&lt;a class="footnote-ref" href="#fn:8" rel="footnote"&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_6"&gt; 使用到的技术 &lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Docker/LXC&lt;/li&gt;
&lt;li&gt;Ansible&lt;/li&gt;
&lt;li&gt;Python &lt;ul&gt;
&lt;li&gt;docker-py&lt;/li&gt;
&lt;li&gt;Jinja2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_7"&gt; 近期规划 &lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt; 拆分 ansible 部分到新的项目 kolla-ansible。kolla 项目只用来做 docker images build. 部署工作由 kolla-ansible, kolla-mesos&lt;sup id="fnref:9"&gt;&lt;a class="footnote-ref" href="#fn:9" rel="footnote"&gt;9&lt;/a&gt;&lt;/sup&gt; 等工具来实现。&lt;/li&gt;
&lt;li&gt; 如何进行平滑的 OpenStack 升级 &lt;/li&gt;
&lt;li&gt;ELK 的集成 &lt;/li&gt;
&lt;li&gt;Swift 自动化 &lt;/li&gt;
&lt;li&gt;Ceilometer Container&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="ref"&gt;REF&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.openstack.org/wiki/Kolla"&gt;Kolla Wiki Page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://review.openstack.org/#/c/248812/"&gt;Add docker module in Kolla&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="https://github.com/ansible/ansible-modules-core/issues/2257"&gt;Docker 1.8.3 is broken under certain conditions&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;&lt;a href="https://review.openstack.org/#/c/260389/"&gt;use oslo.config instead of raw argparse.ArgumentParser&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;&lt;a href="http://lists.openstack.org/pipermail/openstack-dev/2015-December/083089.html"&gt;Mail List: Adding Ubuntu Liberty to Kolla-Mitaka&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;&lt;a href="https://launchpad.net/~ubuntu-cloud-archive/+archive/ubuntu/mitaka-staging"&gt;Staging PPA for mitaka&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;&lt;a href="https://review.openstack.org/#/c/261957/"&gt;Gerrit: Base and openstack-base ubuntu binary containers&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;&lt;a href="https://blueprints.launchpad.net/kolla/+spec/binary-ubuntu"&gt;BP:Ubuntu binary containers&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:8"&gt;
&lt;p&gt;&lt;a href="https://review.openstack.org/#/c/257568/"&gt;Gerrit: Playbook for keystone upgrade&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:8" rev="footnote" title="Jump back to footnote 8 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:9"&gt;
&lt;p&gt;&lt;a href="https://github.com/openstack/kolla-mesos"&gt;kolla-mesos&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:9" rev="footnote" title="Jump back to footnote 9 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Kolla"></category><category term="OpenStack"></category></entry><entry><title>Get all the repo from OpenStack</title><link href="http://xcodest.me/get-all-repos-from-openstack.html" rel="alternate"></link><updated>2016-01-06T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-01-06:get-all-repos-from-openstack.html</id><summary type="html">&lt;p&gt;OpenStack 的源因为你我都知道的原因，一直不稳定，导致 devstack 时经常失败。特定写了个脚本，可以拿到所有的仓库地址，方便做本地的 mirror。&lt;/p&gt;
&lt;p&gt; 脚本在 gist&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; 上。&lt;/p&gt;
&lt;p&gt; 使用方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install PyGithub
python openstack_repo.py -u &amp;lt;github_username&amp;gt; -p &amp;lt;github_password&amp;gt; \
    -o repos.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 跑一次才发现，OpenStack 组下已经有了 600 多个项目。好多啊。&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/b6c36b9f74b743eb4c82.js?file=openstack_repos.py'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
import github
import argparse
import codecs
import logging


DESCRIPTION=u'''

获取 openstack 和 openstack-dev 下所有仓库的列表，输出格式为：

    组织名 仓库名 仓库地址

username 和 password 不是必须的。但是不填写时，会受到 Github Rate Limit[0].
有认证的访问限制是每小时5000次。没有认证的访问限制是每小时60次。

[0] https://developer.github.com/v3/#rate-limiting
'''

def main():
    parser = argparse.ArgumentParser(
        description=DESCRIPTION,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('-u', '--username',
                        help='Usename to connect github')
    parser.add_argument('-p', '--password',
                        help='Password to connect github')
    parser.add_argument('-o', '--output',
                        help='Outout file. Default is stdout')
    parser.add_argument('-O', '--organization',
                        default='openstack,openstack-dev',
                        help='Organization to crawl repos from github')
    parser.add_argument('-d', '--debug',
                        action='store_true',
                        help='Show debug message')
    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        help='Show verbse message')

    conf = parser.parse_args()
    log_level = logging.WARNING
    if conf.verbose:
        log_level = logging.INFO
    if conf.debug:
        log_level = logging.DEBUG

    logging.basicConfig(level=log_level)
    log = logging.getLogger()
    
    gh = github.Github(conf.username, conf.password)

    repos = []
    for org in conf.organization.strip().split(','):
        organization = gh.get_organization(org)
        for repo in organization.get_repos():
            log.info('Get: %s %s %s', org, repo.name, repo.clone_url)
            repos.append((organization, repo))

    if conf.output:
        with codecs.open(conf.output, 'w', 'utf8') as output:
            for org, repo in repos:
                output.write('{} {} {}\n'.format(org.login,
                                               repo.name,
                                               repo.clone_url))
    else:
        for org, repo in repos:
            print('{} {} {}'.format(org.login,
                                    repo.name,
                                    repo.clone_url))

if __name__ == "__main__":
    main()&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;https://gist.github.com/jeffrey4l/b6c36b9f74b743eb4c82&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="OpenStach Python"></category></entry><entry><title>Glance Create Image from Existent Image in Ceph</title><link href="http://xcodest.me/glance-create-image-from-existent-image-in-ceph.html" rel="alternate"></link><updated>2015-06-04T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2015-06-04:glance-create-image-from-existent-image-in-ceph.html</id><summary type="html">&lt;p&gt; 当使用 Ceph + Glance 时，镜像需要使用 RAW 格式，这会导致创建镜像时非常的慢。有的时候，也需要把 Ceph 中现有的镜像导入到 Glance 中。这时可以使用 --location 参数来指定镜像所在的远程位置。也就可以使用现有的 Ceph 镜像来快速创建。&lt;/p&gt;
&lt;p&gt; 可以先用 rbd 上传镜像，转换格式 ( 也会比较慢，还不如直接上传 RAW 格式的镜像 )。然后再做好对应的 snap , 并加以保护。是后一步的 location 必须按格式写 ( 见 [0])，这样才会使用 rbd 的 COW clone 功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# image format 2 support layering&lt;/span&gt;
rbd --image-format &lt;span class="m"&gt;2&lt;/span&gt; import /tmp/ubuntu14.04.2.dsk $uuid

&lt;span class="c1"&gt;# Convert to raw image type&lt;/span&gt;
qemu-img convert -O raw rbd:$pool/$uuid rbd:$pool/$uuid

&lt;span class="c1"&gt;# Make Snapshot and protect it which is require by image clone in nova libvirt.&lt;/span&gt;
rbd --pool images snap create --snap snap $uuid
rbd --pool images snap protect --image $uuid --snap snap

&lt;span class="c1"&gt;# Create Image in Glance&lt;/span&gt;
glance image-create --id $uuid --name ubuntu14.04.2 --disk-format raw --container-format bare --is-public True --location rbd://&lt;span class="nv"&gt;$f&lt;/span&gt;sid/images/$uuid/snap
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="ref"&gt;REF&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[0] &lt;a href="https://github.com/openstack/nova/blob/4a02d9415f64e8d579d1b674d6d2efda902b01fa/nova/virt/libvirt/rbd_utils.py#L179"&gt;https://github.com/openstack/nova/blob/4a02d9415f64e8d579d1b674d6d2efda902b01fa/nova/virt/libvirt/rbd_utils.py#L179&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[1] &lt;a href="http://www.sebastien-han.fr/down/OpenStack%20_%20Ceph%20-%20Liberty.pdf"&gt;http://www.sebastien-han.fr/down/OpenStack%20_%20Ceph%20-%20Liberty.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href="http://www.sebastien-han.fr/blog/2013/05/07/use-existing-rbd-images-and-put-it-into-glance/"&gt;http://www.sebastien-han.fr/blog/2013/05/07/use-existing-rbd-images-and-put-it-into-glance/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>Oz Templates</title><link href="http://xcodest.me/oz-templates.html" rel="alternate"></link><updated>2015-05-11T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2015-05-11:oz-templates.html</id><summary type="html">&lt;p&gt; 最近利用 &lt;a href="https://github.com/clalancette/oz"&gt;OZ&lt;/a&gt; 做了几个常用镜像的自动化制作。回头有用到的会再加进去。说明如下 &lt;/p&gt;
&lt;p&gt; 项目地址 : &lt;a href="https://github.com/jeffrey4l/oz-templates"&gt;https://github.com/jeffrey4l/oz-templates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 以下是 README 里的内容。&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The isos are located in &lt;code&gt;/data/isos/&lt;/code&gt;. The isos' name are conversionally.
Including&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS-6.3-x86_64-bin-DVD1.iso&lt;/li&gt;
&lt;li&gt;RHEL-6.3-x86_64-DVD.iso&lt;/li&gt;
&lt;li&gt;ubuntu-14.04.1-server-amd64.iso&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/clalancette/oz.git
cd oz
git clone https://github.com/jeffrey4l/oz-templates.git
cd oz-templates
make all
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="detail"&gt;Detail&lt;/h2&gt;
&lt;p&gt;The image are configured as following&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;without lvm, which will helpful for partion auto extend.&lt;/li&gt;
&lt;li&gt;Default image size is 40GB&lt;/li&gt;
&lt;li&gt;Installed cloud-init with some basic configuration.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="OpenStack"></category></entry><entry><title>Nova Security Group相关配置</title><link href="http://xcodest.me/nova-security-groupxiang-guan-pei-zhi.html" rel="alternate"></link><updated>2015-03-18T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2015-03-18:nova-security-groupxiang-guan-pei-zhi.html</id><summary type="html">&lt;h1 id="_1"&gt; 相关配置 &lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;network_api_class - 设置 network 模块所用的 api&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nova.network.api.API&lt;/code&gt; - 通过 rpc 与 nova-network 交互 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;nova.network.neutronv2.API&lt;/code&gt; - 通过 http 与 neutron-server 交互 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;security_group_api - 设置 security group 模块所用的 api 类 &lt;ul&gt;
&lt;li&gt;&lt;code&gt;nova&lt;/code&gt; (&lt;code&gt;nova.compute.api.SecurityGroupAPI&lt;/code&gt;) - 通过 rcp 与 nova-compute 交互 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;neutron&lt;/code&gt; ( &lt;code&gt;nova.network.security_group.neutron_driver.SecurityGroupAPI&lt;/code&gt; ) - 通过 http 与 neutron-server 交互 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;linuxnet_interface_driver - 在机器与 ethernet interface plug&amp;amp;unplug 时调用 。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nova.network.linux_net.LinuxBridgeInterfaceDriver&lt;/code&gt; - used in nova-network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nova.network.linux_net.linuxOVSInterfaceDriver&lt;/code&gt; - use in neutron + ml2 + ovs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nova.network.linux_net.NeutronLinuxBridgeInterfaceDriver&lt;/code&gt; - use in neutron + ml2 + linuxbridge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;firewall_driver - 虚拟化层所用的 firewall。在 nova-network 时代，security group 由 iptables 和 ebtables 实现。在 neutron 时代，这个已经不需要了。但是 neutron 里现在还有 arp-spoofing 的 bug, 参见 [2]&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nova.virt.firewall.IptablesFirewallDrive&lt;/code&gt; - &lt;/li&gt;
&lt;li&gt;&lt;code&gt;nova.virt.firewall.NoopFirewallDriver&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt; 使用组合：&lt;/h1&gt;
&lt;p&gt;nova-network + libvirt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nova_api_class=nova.network.api.API
security_group_ap=nova
linuxnet_interface_driver=nova.network.linux_net.LinuxBridgeInterfaceDriver
firewall_driver=nova.virt.firewall.IptablesFirewallDrive
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;neutron + ml2 + linuxbridge plugin + libvirt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nova_api_class=nova.network.neutronv2.API
security_group_ap=neutron
linuxnet_interface_driver=nova.network.linux_net.NeutronLinuxBridgeInterfaceDriver
firewall_driver=nova.virt.firewall.NoopFirewallDriver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;neutron + ml2 + ovs plugin + libvirt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nova_api_class=nova.network.neutronv2.API
security_group_ap=neutron
linuxnet_interface_driver=nova.network.linux_net.linuxOVSInterfaceDriver
firewall_driver=nova.virt.firewall.NoopFirewallDriver
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="ref"&gt;REF&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://kennethjiang.blogspot.jp/2012/02/ebtables-in-openstack-nova-and.html"&gt;ebtables in Openstack Nova&lt;/a&gt; - nwfilter explaination&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blueprints.launchpad.net/neutron/+spec/arp-spoof-patch-ebtables"&gt;Preventing ARP spoofing via ebtables&lt;/a&gt; - Neutron BP for preventing arp snoofing. Expected in Kilo&lt;ol&gt;
&lt;li&gt;&lt;a href="https://bugs.launchpad.net/neutron/+bug/1274034"&gt;Neutron firewall anti-spoofing does not prevent ARP poisoning&lt;/a&gt; - Related bug&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Network"></category></entry><entry><title>Cinder V2 API</title><link href="http://xcodest.me/cinder-v2-api.html" rel="alternate"></link><updated>2015-03-10T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2015-03-10:cinder-v2-api.html</id><summary type="html">&lt;p&gt;cinder v2 api add more feature than v1, Like QoS. And the v1 is marked deprecated in juno and will be removed soon. ( may be in kilo).&lt;/p&gt;
&lt;h1 id="enable-the-v2-in-cinder"&gt;Enable the v2 in cinder&lt;/h1&gt;
&lt;p&gt;Change the following config. The v1 and v2 is enabled in default.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# DEPRECATED: Deploy v1 of the Cinder API. (boolean value)&lt;/span&gt;
&lt;span class="c1"&gt;#enable_v1_api=true&lt;/span&gt;

&lt;span class="c1"&gt;# Deploy v2 of the Cinder API. (boolean value)&lt;/span&gt;
&lt;span class="c1"&gt;#enable_v2_api=true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="enable-the-cinder-v2-api-in-nova"&gt;Enable the cinder v2 api in nova&lt;/h1&gt;
&lt;p&gt;In current nova config ( juno ), the default config like below. Depend on &lt;code&gt;catalog_info&lt;/code&gt; key, it use the v2 first. If v2 is not found, it will fall back to v1 version.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[cinder]&lt;/span&gt;

&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# Options defined in nova.volume.cinder&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;

&lt;span class="c1"&gt;# Info to match when looking for cinder in the service&lt;/span&gt;
&lt;span class="c1"&gt;# catalog. Format is: separated values of the form:&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;service_type&amp;gt;:&amp;lt;service_name&amp;gt;:&amp;lt;endpoint_type&amp;gt; (string value)&lt;/span&gt;
&lt;span class="c1"&gt;#catalog_info=volumev2:cinderv2:publicURL&lt;/span&gt;

&lt;span class="c1"&gt;# Override service catalog lookup with template for cinder&lt;/span&gt;
&lt;span class="c1"&gt;# endpoint e.g. http://localhost:8776/v1/%(project_id)s&lt;/span&gt;
&lt;span class="c1"&gt;# (string value)&lt;/span&gt;
&lt;span class="c1"&gt;#endpoint_template=&amp;lt;None&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;# Region name of this node (string value)&lt;/span&gt;
&lt;span class="c1"&gt;#os_region_name=&amp;lt;None&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;# Number of cinderclient retries on failed http calls (integer&lt;/span&gt;
&lt;span class="c1"&gt;# value)&lt;/span&gt;
&lt;span class="c1"&gt;#http_retries=3&lt;/span&gt;

&lt;span class="c1"&gt;# Allow attach between instance and volume in different&lt;/span&gt;
&lt;span class="c1"&gt;# availability zones. (boolean value)&lt;/span&gt;
&lt;span class="c1"&gt;#cross_az_attach=true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can just add the endpoint to the keystone to enable the cinder v2 api.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;keystone service-create --name&lt;span class="o"&gt;=&lt;/span&gt;cinderv2 --type&lt;span class="o"&gt;=&lt;/span&gt;volumev2 &lt;span class="se"&gt;\&lt;/span&gt;
  --description&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Cinder Volume Service V2&amp;quot;&lt;/span&gt;

keystone endpoint-create &lt;span class="se"&gt;\&lt;/span&gt;
  --service-id&lt;span class="o"&gt;=&lt;/span&gt;the_service_id_above &lt;span class="se"&gt;\&lt;/span&gt;
  --publicurl&lt;span class="o"&gt;=&lt;/span&gt;http://controller:8776/v2/%&lt;span class="se"&gt;\(&lt;/span&gt;tenant_id&lt;span class="se"&gt;\)&lt;/span&gt;s &lt;span class="se"&gt;\&lt;/span&gt;
  --internalurl&lt;span class="o"&gt;=&lt;/span&gt;http://controller:8776/v2/%&lt;span class="se"&gt;\(&lt;/span&gt;tenant_id&lt;span class="se"&gt;\)&lt;/span&gt;s &lt;span class="se"&gt;\&lt;/span&gt;
  --adminurl&lt;span class="o"&gt;=&lt;/span&gt;http://controller:8776/v2/%&lt;span class="se"&gt;\(&lt;/span&gt;tenant_id&lt;span class="se"&gt;\)&lt;/span&gt;s

service cinder-scheduler restart
service cinder-api restart
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="ref"&gt;REF&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;http://docs.openstack.org/havana/install-guide/install/apt/content/cinder-controller.html&lt;/li&gt;
&lt;li&gt;https://wiki.openstack.org/wiki/CinderAPIv2&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Cinder"></category><category term="OpenStack"></category></entry><entry><title>Nova flavor init</title><link href="http://xcodest.me/nova-flavor-init.html" rel="alternate"></link><updated>2014-09-11T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2014-09-11:nova-flavor-init.html</id><summary type="html">&lt;p&gt;ustack 的 flavor 做的还是挺全的，所以用了一个脚本来创建和其一样的 flavor 类型。&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/ecee9fcb00412cd67fe7.js?file=nova-flavor-init.sh'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;#!/bin/bash
#
# This configuration is copy from ustack.com

DEFAULT_ROOT_GB=40

nova-manage flavor create --name micro-1 --cpu 1 --memory 512 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name micro-2 --cpu 1 --memory 1024 --root_gb $DEFAULT_ROOT_GB --is_public True

nova-manage flavor create --name standard-1 --cpu 1 --memory 2048 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name standard-2 --cpu 2 --memory 4096 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name standard-4 --cpu 4 --memory 8192 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name standard-8 --cpu 8 --memory 16384 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name standard-12 --cpu 12 --memory 24576 --root_gb $DEFAULT_ROOT_GB --is_public True

nova-manage flavor create --name memory-1 --cpu 1 --memory 4096 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name memory-2 --cpu 2 --memory 8192 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name memory-4 --cpu 4 --memory 16384 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name memory-8 --cpu 8 --memory 24576 --root_gb $DEFAULT_ROOT_GB --is_public True

nova-manage flavor create --name compute-2 --cpu 2 --memory 2048 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name compute-4 --cpu 4 --memory 4096 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name compute-8 --cpu 8 --memory 8192 --root_gb $DEFAULT_ROOT_GB --is_public True
nova-manage flavor create --name compute-12 --cpu 12 --memory 16384 --root_gb $DEFAULT_ROOT_GB --is_public True
&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;</summary><category term="OpenStack"></category><category term="Nova"></category></entry><entry><title>Glance Image Cache</title><link href="http://xcodest.me/glance-image-cache.html" rel="alternate"></link><updated>2014-07-17T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2014-07-17:glance-image-cache.html</id><summary type="html">&lt;p&gt;Glance 增加了一层 cache 的 Middleware，用来缓存从 file store 后端取过来的镜像。一定
程度上可以加快取镜像的速度。这个功能默认情况下是没开启的。&lt;/p&gt;
&lt;p&gt; 因为是通过 middleware 来控制的，所以只要修改一下 paster 的配置就行。更简单的是指定
glance-api 加载的 pipeline 的名字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[deploy]&lt;/span&gt;
&lt;span class="c1"&gt;# possible value: none, cachine, keystone, keystone+caching, &lt;/span&gt;
&lt;span class="c1"&gt;# keystone+cachemanagement&lt;/span&gt;
&lt;span class="c1"&gt;# This value can get from glance-api-paste.conf file&lt;/span&gt;
&lt;span class="na"&gt;flavor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;keystone+caching&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 具体看下 &lt;code&gt;glance-api-paster.conf&lt;/code&gt; 文件就能明白。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[pipeline:glance-api]&lt;/span&gt;
&lt;span class="na"&gt;pipeline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;versionnegotiation unauthenticated-context rootapp&lt;/span&gt;

&lt;span class="c1"&gt;# Use this pipeline for image caching and no auth&lt;/span&gt;
&lt;span class="k"&gt;[pipeline:glance-api-caching]&lt;/span&gt;
&lt;span class="na"&gt;pipeline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;versionnegotiation unauthenticated-context cache rootapp&lt;/span&gt;

&lt;span class="c1"&gt;# Use this pipeline for caching w/ management interface but no auth&lt;/span&gt;
&lt;span class="k"&gt;[pipeline:glance-api-cachemanagement]&lt;/span&gt;
&lt;span class="na"&gt;pipeline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;versionnegotiation unauthenticated-context cache cachemanage rootapp&lt;/span&gt;

&lt;span class="c1"&gt;# Use this pipeline for keystone auth&lt;/span&gt;
&lt;span class="k"&gt;[pipeline:glance-api-keystone]&lt;/span&gt;
&lt;span class="na"&gt;pipeline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;versionnegotiation authtoken context rootapp&lt;/span&gt;

&lt;span class="c1"&gt;# Use this pipeline for keystone auth with image caching&lt;/span&gt;
&lt;span class="k"&gt;[pipeline:glance-api-keystone+caching]&lt;/span&gt;
&lt;span class="na"&gt;pipeline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;versionnegotiation authtoken context cache rootapp&lt;/span&gt;

&lt;span class="c1"&gt;# Use this pipeline for keystone auth with caching and cache management&lt;/span&gt;
&lt;span class="k"&gt;[pipeline:glance-api-keystone+cachemanagement]&lt;/span&gt;
&lt;span class="na"&gt;pipeline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;versionnegotiation authtoken context cache cachemanage rootapp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 不同的 pipeline 用到了不同的 middleware, 启作用的是 cache 和 cachemanagement 这两个
。&lt;/p&gt;
&lt;h2 id="ref"&gt;REF&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://docs.openstack.org/developer/glance/cache.html"&gt;The Glance Image Cache&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Glance"></category></entry><entry><title>Dhcp lease errors in vlan mode</title><link href="http://xcodest.me/dhcp-lease-errors-in-vlan-mode.html" rel="alternate"></link><updated>2013-08-27T08:50:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2013-08-27:dhcp-lease-errors-in-vlan-mode.html</id><summary type="html">&lt;p&gt; 在使用 &lt;code&gt;keepalived&lt;/code&gt; 的过程中，出现了 dhcp 失败，而导致 keepalived 工作不正常的问题。而且之前也出现过 dhcp 偶尔失败，导致虚拟机不能得到 IP, 从而不能访问的情况。虽然在 &lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt; 中加上了如下语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;PERSISTENT_DHCLIENT=1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 使得 dhcp 单次失败后，继续重试。但是仔细查看 dhclient 的日志后，发现它有大量的 dhcp request 失败 / 超时。在一个 &lt;a href="http://openstack.markmail.org/search/?q=Dhcp+lease+errors+in+vlan+mode#query:Dhcp%20lease%20errors%20in%20vlan%20mode+page:1+mid:7kjf4hljszpydsrx+state:results"&gt; 邮件列表 &lt;/a&gt; 中找到原因，如下：&lt;/p&gt;
&lt;p&gt;To fix issues with failed dhcp leases in vlan mode, upgrade to dnsmasq 2.6.1&lt;/p&gt;
&lt;p&gt;THE LONG VERSION&lt;/p&gt;
&lt;p&gt;There is an issue with the way nova uses dnsmasq in VLAN mode. It starts up a
single copy of dnsmasq for each vlan on the network host (or on every host in
multi_host mode). The problem is in the way that dnsmasq binds to an ip address
and port. Both copies can respond to broadcast packet, but unicast packets
can only be answered by one of the copies.&lt;/p&gt;
&lt;p&gt;In nova this means that guests from only one project will get responses to their
unicast dhcp renew requests.  Unicast projects from guests in other projects get
ignored. What happens next is different depending on the guest os.  Linux
generally will send a broadcast packet out after the unicast fails, and so the
only effect is a small (tens of ms) hiccup while interface is reconfigured.  It
can be much worse than that, however. I have seen cases where Windows just gives
up and ends up with a non-configured interface.&lt;/p&gt;
&lt;p&gt;This bug was first noticed by some users of openstack who rolled their own fix.
Basically, on linux, if you set the SO_BINDTODEVICE socket option, it will allow
different daemons to share the port and respond to unicast packets, as long as
they listen on different interfaces. I managed to communicate with Simon Kelley,
the maintainer of dnsmasq and he has integrated a fix for the issue in the
current version of dnsmaq.&lt;/p&gt;
&lt;p&gt;I don't know how may users out there are using vlan mode, but you should be able
to deal with this issue by upgrading dnsmasq. It would be great if the various
distributionss could upgrade as well, or at least try to patch in the fix. If
upgrading dnsmasq is out of the question, a possible workaround is to minimize
lease renewals with something like the following combination of config options.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# release leases immediately on terminate
force_dhcp_release=true
# one week lease time
dhcp_lease_time=604800
# two week disassociate timeout
fixed_ip_disassociate_timeout=1209600
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is also documented &lt;a href="http://docs.openstack.org/trunk/openstack-compute/admin/content/configuring-vlan-networking.html#vlan-known-issues"&gt; Known issue with failed DHCP leases in VLAN configuration&lt;/a&gt;&lt;/p&gt;</summary><category term="DHCP"></category><category term="Network"></category><category term="VLAN"></category></entry><entry><title>Openstack Brief</title><link href="http://xcodest.me/openstack-brief.html" rel="alternate"></link><updated>2013-06-17T23:08:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2013-06-17:openstack-brief.html</id><summary type="html">&lt;p&gt; 自从 Openstack 诞生之日起，就受到越来越多的开发者，用户的关注。整个代码的规模和质量正在飞速的发展。随着各种功能的增加，Openstack 下面已经拥有了相当多子项目，来完成各种各样的功能。本文将简单介绍各个子项目的功能和发展。所有的项目现状是基于 Grizzly 的版本来写的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keystone&lt;/li&gt;
&lt;li&gt;Nova&lt;/li&gt;
&lt;li&gt;Cinder&lt;/li&gt;
&lt;li&gt;Glance&lt;/li&gt;
&lt;li&gt;Openstack Network(Quantum)&lt;/li&gt;
&lt;li&gt;LBaaS&lt;/li&gt;
&lt;li&gt;Ceilometer&lt;/li&gt;
&lt;li&gt;Baremetal&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="keystone"&gt;Keystone&lt;/h1&gt;
&lt;p&gt;keystone 是 Openstack 的认证和服务注册模块。其结构比较简单。其功能包括 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt; 认证 &lt;/strong&gt; 主要功能是管理用户和用户组的信息，后端可以绑定 ldap, mysql 等认证方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 服务注册模块 &lt;/strong&gt; 主要用于管理 Openstack 相关服务的地址，所有的服务都要先注册到 Keystone 中，才可以使用。它可使用基于文件的模板，也可以使用数据库存储。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Token&lt;/strong&gt; 管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 相对于其它子项目来说，keystone 最近的变化并不是太大。将来一个比较大的变化就是基于 domain 的权限控制，届时 Tenant 里也可以细经出管理员和使用者的角色，并有详细的权限功能控制。&lt;/p&gt;
&lt;h1 id="nova"&gt;Nova&lt;/h1&gt;
&lt;p&gt;Nova 是 Openstack 最早的子项目。现在其它项目如 cinder, quantum(Openstack Network) 都是来自于该项目。可以说这是 Openstack 中最复杂，最主要的部分。它负责 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 用户接口 (nova-api)。处理来自于用户的请求，并做出合理的响应。&lt;/li&gt;
&lt;li&gt; 计算调度 (nova-scheduler)。用于在物理之前进行资源的调配。&lt;/li&gt;
&lt;li&gt; 虚拟化的管理 (nova-compute)。管理虚拟机的适配接口。通过它可以管理真实的虚拟技术驱动的机器，如 KVM, XEN, Hypervisor V 等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 当然还有一些功能如 nova-network, nova-volume 已经从 nova 项目中迁移出来，成为独立的子项目。将来一段时间的变化，主要集中在 nova-network 的废弃，nova-conductor 的更加完善，新的 api(v3) 的支持，对于祼机的支持。&lt;/p&gt;
&lt;h1 id="cinder"&gt;Cinder&lt;/h1&gt;
&lt;p&gt;Cinder 是由 nova-volume 分化而来，用于管理虚拟机的块存储 (block storage), 类似 AWS 的 EBS。其功能主要是创建，维护，删除块存储。后端可以使用 LVM, glusterFs, Ceph, NFS 等软件技术的存储，也可以使用 NetApp, Huawei，IBM 等商用解决方案。当然也可以自己编写自己存储的 Driver 来支持更多的存储类型。&lt;/p&gt;
&lt;h1 id="glance"&gt;Glance&lt;/h1&gt;
&lt;p&gt;Glance 用于管理各种系统的镜像。他后端也可以配置各种存储方案。包括本地，swift, ceph 等。&lt;/p&gt;
&lt;h1 id="openstack-network"&gt;Openstack Network.&lt;/h1&gt;
&lt;p&gt;(Quantum 名称因为商标问题停用）。&lt;/p&gt;
&lt;p&gt; 网络基本是 Openstack 最复杂的模块，涉及到的技术和协议相当多，也最容易出问题。也正因为此，很有必要将网络模块从越来越笨重的 nova 的拿出来。&lt;/p&gt;
&lt;p&gt;Openstack Network 提示了强大的网络服务（Network-as-a-service), 用来实现 L2, L3 层的网络。在原有的 nova-network 的基础之上，增加了相当多的功能 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 加上了 xvlan, gre 等网络技术，并可以编写自己的插件，来增加其功能 &lt;/li&gt;
&lt;li&gt; 使用者可以创建更加丰富的网络模型，如私用路由器等 &lt;/li&gt;
&lt;li&gt; 为 Qos, 流量监控等提供支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 现在 Quantum 还有一些问题，如 HA 方案不成熟，不太适用于 Production。不过根据社区的计划，下一个版本 (H) 将会把 nova-network 废弃掉。所以 Quantum 才是真正的趋势。现在很有必要将其吃透。&lt;/p&gt;
&lt;h1 id="lbaas"&gt;LBaaS&lt;/h1&gt;
&lt;p&gt;Load-Balancer-as-a-service. 在 Quantum 基础上实现的负载均衡。后端既可以使用 haproxy, 也可以使用 cisco, f5 等硬件。（不过我还没有功能搭建过这个服务。&lt;/p&gt;
&lt;h1 id="ceilometer"&gt;Ceilometer&lt;/h1&gt;
&lt;p&gt;Openstack 的计量，计费模块。可以统计 Cpu, IO, Network 使用的详细情况。对公有云和私有云都有极大的好处。现在也有一个 Horizon 的插件，可以直接在 dashboard 里显示使用情况（将来，该插件会合并到 horizon 中）&lt;/p&gt;
&lt;h1 id="baremetal"&gt;Baremetal&lt;/h1&gt;
&lt;p&gt; 增加 Openstack 对裸机的管理功能。可以实现直接对裸机进行系统安装，配置。模糊了虚拟化和物理机之间的界线。现在所有模块包括 nova, glance, cinder 都在努力增强这方面的功能。
这个模块，我更期望是可以建立 Nested-Openstack。同一个 Openstack 环境，既管理物理机，又自动在物理机上安装 Openstack 的模块来成为 Openstack 的一部分。&lt;/p&gt;</summary></entry></feed>