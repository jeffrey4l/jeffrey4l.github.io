<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Xcodest - Others</title><link href="http://xcodest.me/" rel="alternate"></link><link href="http://xcodest.me/feeds/others.atom.xml" rel="self"></link><id>http://xcodest.me/</id><updated>2016-11-14T00:00:00+08:00</updated><entry><title>CentOS 根分区自动扩展</title><link href="http://xcodest.me/centos-root-partition-auto-grow.html" rel="alternate"></link><published>2016-11-14T00:00:00+08:00</published><updated>2016-11-14T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-11-14:/centos-root-partition-auto-grow.html</id><summary type="html">&lt;p&gt;CentOS 5  太老了 ， 完全不支持 。&lt;/p&gt;
&lt;p&gt;CentOS 6  要实现分区自动扩展 ， 要安装以下三个包 &lt;/p&gt;
&lt;pre class="literal-block"&gt;
yum install cloud-init cloud-utils-growpart dracut-modules-growroot
#  生新生成  initramfs
dracut -f
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;dracut&lt;/tt&gt;  把  &lt;tt class="docutils literal"&gt;growroot&lt;/tt&gt;  的脚本封装到  &lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  里面 。  把系统启动时 ，
&lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  利用  &lt;tt class="docutils literal"&gt;growpart&lt;/tt&gt;  命令把根分区进行扩展 。 然后启动真正的 
&lt;tt class="docutils literal"&gt;kernel&lt;/tt&gt;,  之后  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cloud-init&lt;/span&gt;&lt;/tt&gt;  服务会自动把文件系统进行扩展 。&lt;/p&gt;
&lt;p&gt; 之所以使用  &lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  这种方式 ， 原因 [0]：&lt;/p&gt;
&lt;blockquote&gt;
Growpart called by cloud-init only works for kernels &amp;gt;3.8. Only newer …&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;CentOS 5  太老了 ， 完全不支持 。&lt;/p&gt;
&lt;p&gt;CentOS 6  要实现分区自动扩展 ， 要安装以下三个包 &lt;/p&gt;
&lt;pre class="literal-block"&gt;
yum install cloud-init cloud-utils-growpart dracut-modules-growroot
#  生新生成  initramfs
dracut -f
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;dracut&lt;/tt&gt;  把  &lt;tt class="docutils literal"&gt;growroot&lt;/tt&gt;  的脚本封装到  &lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  里面 。  把系统启动时 ，
&lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  利用  &lt;tt class="docutils literal"&gt;growpart&lt;/tt&gt;  命令把根分区进行扩展 。 然后启动真正的 
&lt;tt class="docutils literal"&gt;kernel&lt;/tt&gt;,  之后  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cloud-init&lt;/span&gt;&lt;/tt&gt;  服务会自动把文件系统进行扩展 。&lt;/p&gt;
&lt;p&gt; 之所以使用  &lt;tt class="docutils literal"&gt;initramfs&lt;/tt&gt;  这种方式 ， 原因 [0]：&lt;/p&gt;
&lt;blockquote&gt;
Growpart called by cloud-init only works for kernels &amp;gt;3.8. Only newer
kernels support changing the partition size of a mounted partition. When
using an older kernel the resizing of the root partition happens in the
initrd stage before the root partition is mounted and the subsequent
cloud-init growpart run is a no-op.&lt;/blockquote&gt;
&lt;p&gt;CentOS 7  使用的是  3.10 ( &amp;gt; 3.8 )  的内核 ， 所以并不需要  dracut-modules-growroot
 包 (  源里面也并没有这个包  )。  只安装以下两个包就可以了 。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
yum install cloud-init cloud-utils-growpart
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;[0] &lt;a class="reference external" href="http://openstack.openstack.narkive.com/opyLuPqC/centos-6-5-cloud-init-growpart-resizefs-does-not-work-on-first-boot"&gt;http://openstack.openstack.narkive.com/opyLuPqC/centos-6-5-cloud-init-growpart-resizefs-does-not-work-on-first-boot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="Linux"></category><category term="OpenStack"></category></entry><entry><title>Docker init 进程</title><link href="http://xcodest.me/docker-init-process.html" rel="alternate"></link><published>2016-11-07T00:00:00+08:00</published><updated>2016-11-07T00:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-11-07:/docker-init-process.html</id><summary type="html">&lt;p&gt; 应用容器化后 ， 重启容器的时候 ， 经常会很慢 ， 而且 docker daemon  日志中经常会抛出以 
 下错误 &lt;/p&gt;
&lt;pre class="literal-block"&gt;
dockerd[559]: msg=&amp;quot;Container 5054f failed to exit within 10 seconds of
signal 15 - using the force&amp;quot;
&lt;/pre&gt;
&lt;p&gt; 默认的的  signal 15  根本就没有使其退出 ， 最后还是  10  秒超时后强制退出 (kill) 的 。 而 
 且有时还会出现大量僵尸进程 &lt;/p&gt;
&lt;p&gt; 这可不是一个好现象 。 本文解释其原因及解决方法 。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 背景知识 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt; 信号 &lt;/h3&gt;
&lt;p&gt; 这个是  Linux  最常见一个概念 ， 一般杀死进程时都会用到  &lt;tt class="docutils literal"&gt;kill &amp;lt;pid&amp;gt;&lt;/tt&gt; 。  不同的信 
 号有不同的默认行为 。 用户可以注册自己的信号处理函数 ， 来覆盖掉默认行为 …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt; 应用容器化后 ， 重启容器的时候 ， 经常会很慢 ， 而且 docker daemon  日志中经常会抛出以 
 下错误 &lt;/p&gt;
&lt;pre class="literal-block"&gt;
dockerd[559]: msg=&amp;quot;Container 5054f failed to exit within 10 seconds of
signal 15 - using the force&amp;quot;
&lt;/pre&gt;
&lt;p&gt; 默认的的  signal 15  根本就没有使其退出 ， 最后还是  10  秒超时后强制退出 (kill) 的 。 而 
 且有时还会出现大量僵尸进程 &lt;/p&gt;
&lt;p&gt; 这可不是一个好现象 。 本文解释其原因及解决方法 。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt; 背景知识 &lt;/h2&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt; 信号 &lt;/h3&gt;
&lt;p&gt; 这个是  Linux  最常见一个概念 ， 一般杀死进程时都会用到  &lt;tt class="docutils literal"&gt;kill &amp;lt;pid&amp;gt;&lt;/tt&gt; 。  不同的信 
 号有不同的默认行为 。 用户可以注册自己的信号处理函数 ， 来覆盖掉默认行为 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt; 僵尸进程 &lt;/h3&gt;
&lt;p&gt; 僵尸进程是终止运行的进程 ， 为什么它们是有害的 ?&lt;/p&gt;
&lt;p&gt; 虽然应用申请的内存已经释放了 ， 但是你依然能通过  &lt;tt class="docutils literal"&gt;ps&lt;/tt&gt;  看到它 。 这是因为有一些内 
 核资源没有释放 。 下面是  Linux &lt;tt class="docutils literal"&gt;waitpid&lt;/tt&gt;  的  man page:&lt;/p&gt;
&lt;blockquote&gt;
As long as a zombie is not removed from the system via a wait, it will
consume a slot in the kernel process table, and if this table fills, it
will not be possible to create further processes.&amp;quot;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt; 容器化后的问题 &lt;/h2&gt;
&lt;p&gt; 容器化后 ， 由于单容器单进程 ， 已经没有传统意义上的  init  进程了 。 应用进程直接占用 
 了  pid 1  的进程号 。 从而导致以下两个问题 。&lt;/p&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt; 进程不能正常终止 &lt;/h3&gt;
&lt;p&gt;Linux  内核中会对  pid 1  进程发送特殊的信号量 。&lt;/p&gt;
&lt;p&gt; 一般情况下 ， 当给一个进程发送信号时 ， 内核会先检查是否有用户定义的处理函数 ， 如果 
 没有 ， 就会回退到默认行为 。 例如使用  SIGTERM  直接杀死进程 。 然而 ， 如果进程的  PID
 是  1,  内核会特殊对待它 。 如果没有没有注册用户处理函数 ， 内核不会回退到默认行为 ，
 什么也不做 。 换句话说 ， 如果你的进程没有处理信号的函数 ， 给他发送  &lt;tt class="docutils literal"&gt;SIGTERM&lt;/tt&gt;  会一 
 点效果也没有 。&lt;/p&gt;
&lt;p&gt; 常见的使用是  docker run my-container script.  给  &lt;tt class="docutils literal"&gt;docker run&lt;/tt&gt;  进程发送 
&lt;tt class="docutils literal"&gt;SIGTERM&lt;/tt&gt;  信号会杀掉  &lt;tt class="docutils literal"&gt;docker run&lt;/tt&gt;  进程 ， 但是容器还在后台运行 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt; 孤儿僵尸进程不能正常回收 &lt;/h3&gt;
&lt;p&gt; 当进程退出时 ， 它会变成僵尸进程 ， 直到它的父进程调用  &lt;tt class="docutils literal"&gt;wait()&lt;/tt&gt; (  或其变种  )  的系 
 统调用 。process table  里面会把它的标记为  &lt;tt class="docutils literal"&gt;defunct&lt;/tt&gt;  状态 。 一般情况下 ， 父进程应 
 该立即调用  &lt;tt class="docutils literal"&gt;wait()&lt;/tt&gt;,  以防僵尸进程时间过长 。&lt;/p&gt;
&lt;p&gt; 如果父进程在子进程之前退出 ， 子进程会变成孤儿进程 ,  它的父进程会变成  PID 1。 因此 
，init  进程就要对这些进程负责 ， 并在适当的时候调用  &lt;tt class="docutils literal"&gt;wait()&lt;/tt&gt;  方法 。&lt;/p&gt;
&lt;p&gt; 但是 ， 通常情况下 ， 大部分进程不会处理偶然依附在自己进程上的随机子进程 ， 所以在容器 
 中 ， 会出现许多僵尸进程 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt; 解决方案 &lt;/h2&gt;
&lt;p&gt; 让所有的应用能正确的处理以上的情况 ， 不太现实 。 好在现在有很多解决方案 ， 例如 
dumb-init [0] 。 他像是一个小型  init  服务 ， 他启动一个子进程并转发所有接收到的信 
 号量给子进程 。 而且不需要修改应用代码 。&lt;/p&gt;
&lt;p&gt; 此时你的应用进程已经不是  pid 1  了 ， 所以已经没有上面提到的问题 。 而且  dumb-init
 也会转发所有的信号给子进程 ， 应用的形为和在没有  dumb-init  时是一样的 。 如果应用进 
 程死掉了 ，dumb-init  进程也会死掉 ， 并会清理所有其它的子进程 。&lt;/p&gt;
&lt;p&gt; 使用方法如下 ,  在  Dockerfile  里面加上 ：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# install dumb-init
RUN wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64
RUN chmod +x /usr/local/bin/dumb-init

# Runs &amp;quot;/usr/bin/dumb-init -- /my/script --with --args&amp;quot;
ENTRYPOINT [&amp;quot;/usr/bin/dumb-init&amp;quot;, &amp;quot;--&amp;quot;]
CMD [&amp;quot;/my/script&amp;quot;, &amp;quot;--with&amp;quot;, &amp;quot;--args&amp;quot;]
&lt;/pre&gt;
&lt;p&gt; 类似的方案  tini [1], pidunu[3]&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="kolla"&gt;
&lt;h2&gt;Kolla  相关 &lt;/h2&gt;
&lt;p&gt;Kolla  最近已经发布了  newton  版本的  release 。  已经加上了  dumb-init  的解决方案 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt; 参考资料 &lt;/h2&gt;
&lt;p&gt;[0] &lt;a class="reference external" href="https://github.com/Yelp/dumb-init"&gt;https://github.com/Yelp/dumb-init&lt;/a&gt;
[1] &lt;a class="reference external" href="https://github.com/krallin/tini"&gt;https://github.com/krallin/tini&lt;/a&gt;
[2] &lt;a class="reference external" href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem"&gt;https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem&lt;/a&gt;
[3] &lt;a class="reference external" href="https://github.com/rciorba/pidunu"&gt;https://github.com/rciorba/pidunu&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</content><category term="Linux"></category><category term="Docker"></category></entry><entry><title>Reset Password in Systemd</title><link href="http://xcodest.me/reset-password-in-systemd.html" rel="alternate"></link><published>2016-08-28T10:00:00+08:00</published><updated>2016-08-28T10:00:00+08:00</updated><author><name>Jeffrey4l</name></author><id>tag:xcodest.me,2016-08-28:/reset-password-in-systemd.html</id><summary type="html">&lt;p&gt; 现在基本是用  ssh key  来登录系统了 。 之前可以直接在  GRUB  直接进单用户改密码 。 使用了  systemd  的系统 ， 后已经不可以这么使用了 。 原因是  Systemd  的单用户模式使用了  &lt;tt class="docutils literal"&gt;/usr/sbin/sulogin&lt;/tt&gt;  这个  shell,  也必须输入密码才可以 。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# /usr/lib/systemd/system/rescue.service
[Unit]
Description=Rescue Shell
Documentation=man:sulogin(8)
DefaultDependencies=no
Conflicts=shutdown.target
After=sysinit.target plymouth-start.service
Before=shutdown.target

[Service]
Environment=HOME …&lt;/pre&gt;</summary><content type="html">&lt;p&gt; 现在基本是用  ssh key  来登录系统了 。 之前可以直接在  GRUB  直接进单用户改密码 。 使用了  systemd  的系统 ， 后已经不可以这么使用了 。 原因是  Systemd  的单用户模式使用了  &lt;tt class="docutils literal"&gt;/usr/sbin/sulogin&lt;/tt&gt;  这个  shell,  也必须输入密码才可以 。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# /usr/lib/systemd/system/rescue.service
[Unit]
Description=Rescue Shell
Documentation=man:sulogin(8)
DefaultDependencies=no
Conflicts=shutdown.target
After=sysinit.target plymouth-start.service
Before=shutdown.target

[Service]
Environment=HOME=/root
WorkingDirectory=-/root
ExecStartPre=-/bin/plymouth --wait quit
ExecStartPre=-/bin/echo -e 'You are in rescue mode. After logging in, type &amp;quot;journalctl -xb&amp;quot; to view\\nsystem logs, &amp;quot;systemctl reboot&amp;quot; to reboot, &amp;quot;systemctl default&amp;quot; or ^D to\\nboot into default mode.'
ExecStart=-/bin/sh -c &amp;quot;/usr/bin/sulogin; /usr/bin/systemctl --job-mode=fail --no-block default&amp;quot;
Type=idle
StandardInput=tty-force
StandardOutput=inherit
StandardError=inherit
KillMode=process
IgnoreSIGPIPE=no
SendSIGHUP=yes
&lt;/pre&gt;
&lt;p&gt; 自  systemd 215  版本后 ， 新加了一个  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;systemd.debug-shell&lt;/span&gt;&lt;/tt&gt;  的内核参数 ， 内容如下 ：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# /usr/lib/systemd/system/debug-shell.service
[Unit]
Description=Early root shell on /dev/tty9 FOR DEBUGGING ONLY
Documentation=man:sushell(8)
DefaultDependencies=no
IgnoreOnIsolate=yes
ConditionPathExists=/dev/tty9

[Service]
Environment=TERM=linux
ExecStart=/bin/sh
Restart=always
RestartSec=0
StandardInput=tty
TTYPath=/dev/tty9
TTYReset=yes
TTYVHangup=yes
KillMode=process
IgnoreSIGPIPE=no
# bash ignores SIGTERM
KillSignal=SIGHUP

# Unset locale for the console getty since the console has problems
# displaying some internationalized messages.
Environment=LANG= LANGUAGE= LC_CTYPE= LC_NUMERIC= LC_TIME= LC_COLLATE= LC_MONETARY= LC_MESSAGES= LC_PAPER= LC_NAME= LC_ADDRESS= LC_TELEPHONE= LC_MEASUREMENT= LC_IDENTIFICATION=

[Install]
WantedBy=sysinit.target
&lt;/pre&gt;
&lt;p&gt; 可以看到 ，systemd  直接在  &lt;tt class="docutils literal"&gt;tty9&lt;/tt&gt;  上面开了一个  sh,  不用密码就可以登录 。&lt;/p&gt;
&lt;p&gt; 使用方法很简单 ， 在  GRUB  界面上 ， 输入  &lt;tt class="docutils literal"&gt;e&lt;/tt&gt;  进入编辑模式 ， 找到  &lt;tt class="docutils literal"&gt;linux16&lt;/tt&gt;  那一行 ， 在后面加入  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;systemd.debug-shell&lt;/span&gt;&lt;/tt&gt;  就可以了 。 之后  &lt;tt class="docutils literal"&gt;Ctrl + x&lt;/tt&gt;  继续启动就可以了 。 启动完成后 ，&lt;tt class="docutils literal"&gt;Ctrl + Alt + F9&lt;/tt&gt;  进入  &lt;tt class="docutils literal"&gt;tty9&lt;/tt&gt;，  就可以欢快的改密码了 &lt;/p&gt;
</content><category term="Linux"></category><category term="Systemd"></category></entry></feed>