
<html>
<head>
    <meta http-equiv=Content-Type content="text/html;charset=utf-8">
    <link rel="stylesheet" href="theme/css/wechat.css" type="text/css" charset="utf-8">
</head>
<body>
  <p>When using <code>KeyboardInterrupt</code>(<code>Ctrl+c</code>) interrupt the excution of the <code>multiprocess.Pool</code>, it will not work as expected. Following is a demo</p>
<pre class="codehilite"><code class="language-python">import time
from multiprocessing import Pool


def worker():
    while True:
        time.sleep(1)

pool = Pool(1)

pool.apply(worker)</code></pre>


<p>When run the code and try to <code>Ctrl+C</code> to stop it, it will never be stopped.</p>
<pre class="codehilite"><code>$ python2 b.py                                                                      
^CProcess PoolWorker-1:
Traceback (most recent call last):
  File &quot;/usr/lib/python2.7/multiprocessing/process.py&quot;, line 258, in _bootstrap
    self.run()
  File &quot;/usr/lib/python2.7/multiprocessing/process.py&quot;, line 114, in run
    self._target(*self._args, **self._kwargs)
  File &quot;/usr/lib/python2.7/multiprocessing/pool.py&quot;, line 113, in worker
    result = (True, func(*args, **kwds))
  File &quot;b.py&quot;, line 7, in worker
    time.sleep(1)
KeyboardInterrupt</code></pre>


<p>The root cause is explained in <a href="http://stackoverflow.com/a/1408476/893981">stackoverflow</a>. And the bug is <a href="http://bugs.python.org/issue8296">here</a></p>
<blockquote>
This is a Python bug. When waiting for a condition in threading.Condition.wait(), KeyboardInterrupt is never sent. Repro:

<pre>
import threading
cond = threading.Condition(threading.Lock())
cond.acquire()
cond.wait(None)
print "done"
</pre>

The KeyboardInterrupt exception won't be delivered until wait() returns, and it never returns, so the interrupt never happens. KeyboardInterrupt should almost certainly interrupt a condition wait.

Note that this doesn't happen if a timeout is specified; cond.wait(1) will receive the interrupt immediately. So, a workaround is to specify a timeout. To do that, replace

<pre>
    results = pool.map(slowly_square, range(40))
</pre>

with

<pre>
    results = pool.map_async(slowly_square, range(40)).get(9999999)
</pre>

or similar.
</blockquote>

<p>By using this, we can interrupt the Pool by using <code>Ctrl+c</code>.</p>
<p>Here is a better version.</p>
<pre class="codehilite"><code class="language-python">import multiprocessing
from multiprocessing import Pool
import time
import signal


def worker():
    while True:
        print time.time()
        time.sleep(.5)

def worker_init():
    # ignore the SIGINI in sub process, just print a log
    def sig_int(signal_num, frame):
        print 'signal: %s' % signal_num
    signal.signal(signal.SIGINT, sig_int)


pool = Pool(2, worker_init)
result = pool.apply_async(worker)
while True:
    try:
        result.get(0xfff)
    # catch TimeoutError and get again
    except multiprocessing.TimeoutError as ex:
        print 'timeout'</code></pre>


<h1 id="ref">REF</h1>
<ul>
<li><a href="http://bugs.python.org/issue8296">Python Bug</a></li>
<li><a href="http://unix.stackexchange.com/a/149756">How Ctrl+c works</a></li>
<li><a href="http://stackoverflow.com/a/1408476/893981">Keyboard Interrupts with python's multiprocessing Pool</a></li>
</ul>
</body>
</html>
